<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钱多多の博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cybaol.github.io/"/>
  <updated>2019-11-19T16:47:20.318Z</updated>
  <id>https://cybaol.github.io/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Be a magical developer</title>
    <link href="https://cybaol.github.io/2019/11/19/ambition/"/>
    <id>https://cybaol.github.io/2019/11/19/ambition/</id>
    <published>2019-11-19T15:15:37.000Z</published>
    <updated>2019-11-19T16:47:20.318Z</updated>
    
    <content type="html"><![CDATA[<p>《一百种自杀方法》最后一页写着活下去。</p><a id="more"></a><ul><li><a href="https://www.choupangxia.com/2019/09/26/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/" target="_blank" rel="noopener">费曼学习法</a>  </li><li>康奈尔笔记  </li><li>计算机组成原理(秃头程序员的进阶感觉可还行)(<a href="https://www.bilibili.com/video/av15123338" target="_blank" rel="noopener">哈工大</a>)  </li><li>数据结构与算法(不C9 无算法 一直都坚信它是程序的灵魂 加油)(<a href="https://www.bilibili.com/video/av7134874" target="_blank" rel="noopener">北大</a>+<a href="https://www.bilibili.com/video/av49361421" target="_blank" rel="noopener">清华</a>+算法导论原书第三版)  </li><li>操作系统(听说过bug10吧) (<a href="https://www.bilibili.com/video/av6538245" target="_blank" rel="noopener">北大</a>)  </li><li>计算机网络(学好卖网线)(<a href="./计算机网络原理：自顶向下方法（第6版）.pdf">自顶而下英文原版</a>)  </li><li>编译原理(<a href="https://www.bilibili.com/video/av17649289" target="_blank" rel="noopener">哈工大</a>)</li><li>嵌入式系统(<a href="https://www.bilibili.com/video/av29287517" target="_blank" rel="noopener">清华</a>)</li><li>信息论与编码（<a href="https://www.bilibili.com/video/av28661250" target="_blank" rel="noopener">清华</a>+<a href="https://www.bilibili.com/video/av26735580" target="_blank" rel="noopener">西电</a>）</li><li><a href="https://www.bilibili.com/video/av9912938" target="_blank" rel="noopener">机器学习</a>  </li><li>前端  </li><li>数据库  </li><li>健身  </li><li>个人札记  <ol><li>学点经济学</li><li>为竞赛而生  </li><li>多看英文原版书  </li><li>多线程+设计模式  </li><li>多看项目源码  </li><li>脚踏实地的理想主义者，既要有高远的理想也要有脚踏实地的精神  </li><li>他们只是起点比我们高 – 2018-10-3 打卡南京大学鼓楼校区  </li><li>见见有趣的人，读读有趣的书，讲讲有趣的故事。  </li><li>有时候我们会觉得自己后知后觉，那是因为学习的太少，了解的太少，很多问题前人已经总结好了现成的方法和方案，我们却不知道，还在自己探索，当然行动缓慢，后知后觉了。只有站在巨人的肩膀上才能看得更远。   </li><li>2019-10-26打卡东南大学四牌楼校区图书馆  </li><li>备战华北电力大学计算机专硕（<a href="./华北电力大学2020专业课大纲.doc">844数据结构</a>）  </li><li><a href="https://app.yinxiang.com/shard/s40/nl/24222849/82d590e6-3c3b-4af1-87c2-8964f41501e9/" target="_blank" rel="noopener">C语言笔记</a>  </li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《一百种自杀方法》最后一页写着活下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="techs" scheme="https://cybaol.github.io/categories/techs/"/>
    
    
      <category term="成长" scheme="https://cybaol.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>大学阅读记录</title>
    <link href="https://cybaol.github.io/2019/11/07/book/"/>
    <id>https://cybaol.github.io/2019/11/07/book/</id>
    <published>2019-11-07T11:32:37.000Z</published>
    <updated>2020-03-12T02:02:09.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./20191120135008.jpg" alt="一起努力(劝退)"></p><a id="more"></a><h2 id="1-算法类"><a href="#1-算法类" class="headerlink" title="1. 算法类"></a>1. 算法类</h2><p>花费我时间最长的东西 不放在第一位都觉得对不起自己.  </p><ul><li>算法导论  </li><li>大话数据结构  </li><li>算法笔记  </li><li>算法笔记上机训练实战指南    </li><li>算法之美  </li><li>初等数论  </li><li>啊哈算法   </li><li>算法竞赛入门经典（第2版）  </li><li>算法竞赛入门经典训练指南  </li><li>大学生程序设计课程与竞赛训练教材-算法设计编程实验 <h2 id="2-语言类杂书"><a href="#2-语言类杂书" class="headerlink" title="2. 语言类杂书"></a>2. 语言类杂书</h2>同类书籍看了一堆又一堆 就觉得这几本有点意思(索然无味).  </li><li>C Traps and Pitfalls   </li><li>Expert C Programming  </li><li>C Pointer  </li><li>C++ STL  </li><li>C++ 11 新标准  </li><li>C++ 编程思想  </li><li>Effective C++  </li><li>More Effective C++  </li><li>Computer Network A Top-Down Approach  </li><li>CSAPP<h2 id="3-Python小爬虫"><a href="#3-Python小爬虫" class="headerlink" title="3. Python小爬虫"></a>3. Python小爬虫</h2>骚不动系列，只看了一本两个晚上93分过期末。。。  </li><li>Python编程:从入门到实践  <h2 id="4-程序人生"><a href="#4-程序人生" class="headerlink" title="4. 程序人生"></a>4. 程序人生</h2></li><li>数学之美</li><li>浪潮之巅  <h2 id="5-人文社科类"><a href="#5-人文社科类" class="headerlink" title="5. 人文社科类"></a>5. 人文社科类</h2></li><li>愿你与这世界温暖相拥</li><li>一寸一寸暖你</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./20191120135008.jpg&quot; alt=&quot;一起努力(劝退)&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="books" scheme="https://cybaol.github.io/categories/books/"/>
    
    
      <category term="阅读" scheme="https://cybaol.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>图论算法</title>
    <link href="https://cybaol.github.io/2019/11/01/Graph/"/>
    <id>https://cybaol.github.io/2019/11/01/Graph/</id>
    <published>2019-11-01T03:00:37.000Z</published>
    <updated>2020-03-12T11:51:04.653Z</updated>
    
    <content type="html"><![CDATA[<p>加油 奥利给</p><a id="more"></a><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><pre><code>* 有两种存储方式：邻接矩阵和邻接表* 在一些顶点数目比较大（一般顶点个数在1000以上）的情况下，使用邻接表而  不是邻接矩阵来存储图。如果是稀疏图，用邻接表，如果是稠密图，用邻接矩阵。</code></pre><h2 id="深度优先搜索dfs遍历图"><a href="#深度优先搜索dfs遍历图" class="headerlink" title="深度优先搜索dfs遍历图"></a>深度优先搜索dfs遍历图</h2><ul><li>按深度优先的方式访问所有未被访问的结点，在结点被访问过后标记为已访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dfs(u) &#123;</span><br><span class="line">  vis[u] = true;</span><br><span class="line">  for(从u出发到能到达的所有顶点v)</span><br><span class="line">    if(vis[v] == false)</span><br><span class="line">      dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">dfsTrave(G) &#123;</span><br><span class="line">  for(G的所有顶点u)</span><br><span class="line">    if(vis[u] == false)</span><br><span class="line">      dfs(u); //访问u所在连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵版 DFS</span><br><span class="line"></span><br><span class="line">int n, G[maxV][maxV];//n顶点数 maxV最大顶点数</span><br><span class="line">bool vis[maxV] = &#123;false&#125;;//记录顶点是否被访问过</span><br><span class="line"></span><br><span class="line">void dfs(int u, int depth) &#123;</span><br><span class="line">    vis[u] = true;</span><br><span class="line">    for(int v = 0; v &lt; n; v++)//遍历u可以到达的顶点v</span><br><span class="line">        if(G[u][v] != INF &amp;&amp; vis[v] == false)</span><br><span class="line">            dfs(v, depth + 1);//访问v 深度+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void travelDFS() &#123;</span><br><span class="line">    for(int u = 0; u &lt; n; u++)</span><br><span class="line">        if(vis[u] == false)</span><br><span class="line">            dfs(u, 1);//访问u和u所在的连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//邻接表版 DFS</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; arr[maxn];</span><br><span class="line"></span><br><span class="line">void dfs(int u, int depth) &#123;</span><br><span class="line">  vis[u] = true;</span><br><span class="line">  for(int i = 0; i &lt; arr[u].size(); i++)&#123;</span><br><span class="line">int v = arr[u][i];</span><br><span class="line">if(vis[i] == false)</span><br><span class="line">    dfs(v, depth + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfsTrave() &#123;</span><br><span class="line">  for(int u = 0; u &lt; n; u++) &#123;</span><br><span class="line">    if(vis[u] == false)</span><br><span class="line">      dfs(u, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs遍历图"><a href="#广度优先搜索bfs遍历图" class="headerlink" title="广度优先搜索bfs遍历图"></a>广度优先搜索bfs遍历图</h2><ul><li>建立一个队列，把初始定点加入队列，然后每次都取出队首元素进行访问，并把该定点<br>除法可以到达的未曾加入过队列（而不是未访问）的顶点全部加入队列，直到队列为空。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bfs(u) &#123;</span><br><span class="line">  queue q;</span><br><span class="line">  将u入队</span><br><span class="line">  inq[u] = true;</span><br><span class="line">  while(q非空) &#123;</span><br><span class="line">    for(从u出发到可到达的所有顶点v) &#123;</span><br><span class="line">      if(inq[v] == false)</span><br><span class="line">        将v入队</span><br><span class="line">        inq[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfsTrave(G) &#123;</span><br><span class="line">  for(G的所有顶点u) &#123;</span><br><span class="line">    if(inq[u] == false)</span><br><span class="line">      bfs(u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵版 BFS</span><br><span class="line">int n, G[maxV][maxV];//n顶点数 maxV最大顶点数</span><br><span class="line">bool inq[maxV] = &#123;false&#125;;//记录顶点的是否入队</span><br><span class="line"></span><br><span class="line">void bfs(int u) &#123;//u顶点编号</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(u);//入队</span><br><span class="line">inq[u] = true;</span><br><span class="line">while(!q.empty()) &#123;</span><br><span class="line">int u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int v = 0; v &lt; n; ++v)//遍历u所在连通块（未入队）并入队</span><br><span class="line">if(G[u][v] != INF &amp;&amp; inq[v] == false)&#123;</span><br><span class="line">q.push(v);、</span><br><span class="line">inq[v] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*邻接表：</span><br><span class="line">for(int i = 0; i &lt; arr[u].size(); i++) &#123;</span><br><span class="line">  int v= arr[u][i];</span><br><span class="line">  if(inq[v] == false) &#123;</span><br><span class="line">    q.push(v);</span><br><span class="line">    inq[v] = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void travelBFS() &#123;</span><br><span class="line">for(int v = 0; v &lt; n; ++v)</span><br><span class="line">if (inq[v] == false)</span><br><span class="line">bfs(v);//遍历v及其所在连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//带层数的 邻接表</span><br><span class="line">struct node &#123;</span><br><span class="line">  int v;//顶点编号</span><br><span class="line">  int layer;//顶点层号</span><br><span class="line">&#125;;</span><br><span class="line">next.layer = curNode.layer + 1;</span><br><span class="line">//邻接表中的类型是node，而不是int</span><br><span class="line">vector&lt;node&gt; Adj[N];</span><br></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><pre><code>单源最短路径：计算源点到其他各顶点的最短路径的长度全局最短路径：图中任意两点的最短路径Dijkstra、Bellman-Ford、SPFA求单源最短路径Floyd可以求全局最短路径，但是效率比较低SPFA算法是Bellman-Ford算法的队列优化Dijkstra算法不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径。Bellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行。深度优先遍历可以求一个点到另一个点的最短路径的长度</code></pre><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><pre><code>思想来源：图的广度优先遍历bfs</code></pre><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int G[maxSize][maxSize], n;</span><br><span class="line">int d[maxSize];</span><br><span class="line">int pre[maxSize];</span><br><span class="line">bool vis[maxSize] = &#123;false&#125;;</span><br><span class="line">//邻接矩阵</span><br><span class="line">void Dijkstra(int s) &#123; //T(n) = O(V^2)</span><br><span class="line">fill(d, d + maxSize, INF);</span><br><span class="line">d[s] = 0;</span><br><span class="line">for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">int u = -1, min = INF;//u 保存最短路径顶点，min保存最短距离</span><br><span class="line">for (int j = 0; j &lt; n; ++j)</span><br><span class="line">if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123;</span><br><span class="line">u = j;</span><br><span class="line">min = d[j];</span><br><span class="line">&#125;</span><br><span class="line">//找不到小于INF的d[u]，说明剩下的顶点与起点s不连通</span><br><span class="line">if(u == -1) return;</span><br><span class="line">vis[u] = true;</span><br><span class="line">for (int v = 0; v&lt; n; ++v) &#123;</span><br><span class="line">//以u为中介点使可以使d[v]更优</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">pre[v] = u; //记录v的前驱结点u</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//邻接表</span><br><span class="line">struct Node &#123;</span><br><span class="line">int v, dis; //v为边的目标顶点，dis为边权</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; Adj[MAXV]</span><br><span class="line"></span><br><span class="line">for(int j = 0; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">int v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v</span><br><span class="line">if(vis[v] == false &amp;&amp; d[u] + Adj[u][v].dis &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + Adj[u][v].dis;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//无向图解决方案: 把无向边当成指向相反的有向边</span><br><span class="line"></span><br><span class="line">void DFS(int s, int v) &#123;//s起点编号，v是当前访问的顶点编号（从终点开始递归）</span><br><span class="line">if(v == s) &#123; //如果当前已经打扫起点s，则输出起点并返回</span><br><span class="line">printf(&quot;%d\n&quot;, s);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">DFS(s, pre[v]); //递归访问v的前驱结点pre[v]</span><br><span class="line">printf(&quot;%d\n&quot;, v);//从最深处return回来之后，输出每一层的顶点号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>附加考法：第一标尺是距离，第二标尺常见有三种①新增边权：给每条边再增加一个边权（比如花费），然后要求在最短路径有多条时要求路径上的花费之和最小（如果边权是其它含义，也可以是最大）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//c[] 从起点s到达顶点u的最少花费c[u]</span><br><span class="line">//cost[u][v]表示u-&gt;v的花费</span><br><span class="line">//初始化时只有c[s] = 0 其余均为INF</span><br><span class="line">for(int v; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">c[v] = c[u] +cost[u][v];</span><br><span class="line">&#125;else if(d[u] + G[u][v] == d[v] &amp;&amp; c[u] +cost[u][v] &lt; c[v])&#123;</span><br><span class="line">c[v] = c[u] +cost[u][v];//最短距离相同时，看c[v]能否更优</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>②新增点权：给每个点增加一个点权（例如每个城市能收集到的物资），然后在最短路径有多条时要求路径上的点权之和最大（如果点权是其它含义也可以是最小）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//w[]从起点s到顶点u能收集的最大物资w[u]</span><br><span class="line">//weight[u]表示城市u中的物资数目</span><br><span class="line">//初始化时只有w[s]为weight[u] 其余均为0</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">w[v] = w[u] + weight[v];</span><br><span class="line">&#125;</span><br><span class="line">else if(d[u] + G[u][v] == d[v] &amp;&amp; w[u] + weight[v] &gt; w[v])&#123;</span><br><span class="line">w[v] = w[u] + weight[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>③直接问有多少条最短路径</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//num[]从起点s到达顶点u的最短路径条数为num[u]</span><br><span class="line">//初始化只有num[s] = 1 其余均为0</span><br><span class="line">for(int v; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">num[v] = num[u];</span><br><span class="line">&#125;</span><br><span class="line">else if(d[u] + G[u][v] == d[v])&#123;</span><br><span class="line">num[v] += num[u];//最短距离相同时累加num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全源最短路径"><a href="#全源最短路径" class="headerlink" title="全源最短路径"></a>全源最短路径</h2><h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Floyd算法</span><br><span class="line">枚举顶点 k ∈ [1,n]</span><br><span class="line">以顶点 k 作为中介点，枚举所有顶点对i和j （i，j∈ [1,n]）</span><br><span class="line">如果dis[i][k] + dis[k][j] &lt; dis[i][j]成立</span><br><span class="line">赋值dis[i][j] = dis[i][k] + dis[k][j]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int n, m; //n顶点数， m为边数</span><br><span class="line">int dis[MAXV][MAXV]; //dis[i][j]表示顶点i和j的最短距离</span><br><span class="line"></span><br><span class="line">void Floyd()&#123;</span><br><span class="line">for(int k = 0; k &lt; n; k++) &#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">if(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])</span><br><span class="line">dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><pre><code>如果是稠密图(边多) prim算法如果是稀疏图(边少) kruskal算法</code></pre><h2 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prim算法：对图G(V,E)设置集合S，存放已被访问的顶点，然后每次从集合V-S中选择</span><br><span class="line">与集合S的最短距离最小的一个顶点（记为u）访问并加入集合S。之后，令顶点u为中介点，</span><br><span class="line">优化所有从u能到达的顶点v与集合S之间的最短距离。这样执行操作n次（n为顶点个数），</span><br><span class="line">直到集合S已包含所有顶点。</span><br><span class="line">Prim(G, d[])&#123;</span><br><span class="line">初始化</span><br><span class="line">for(循环n次)&#123;</span><br><span class="line">u = 使d[u]最小的还未被访问的顶点的标号</span><br><span class="line">for(从u除法能到达的所有顶点)&#123;</span><br><span class="line">if(v未被访问&amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)&#123;</span><br><span class="line">将G[u][v]赋值给v与集合S的最短距离d[v]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵</span><br><span class="line">int n, G[MAXV][MAXV]; //n为顶点数</span><br><span class="line">int d[MAXV]; //顶点与集合S的最短距离</span><br><span class="line">bool vis[MAXV] = &#123;false&#125;; //标记数组，vis[i] == true表示已访问。初值均为false</span><br><span class="line"></span><br><span class="line">int prim()&#123;//默认0号为初始点</span><br><span class="line">fill(d, d + MAXV, INF);</span><br><span class="line">d[0] = 0;</span><br><span class="line">int ans = 0; //存放最小生成树的边权之和</span><br><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">int u = -1, min = INF; //u使d[u]最小，min存放该最小的d[u]</span><br><span class="line">for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123;</span><br><span class="line">u = j;</span><br><span class="line">min = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//找不到小于INF的d[u]，则剩下的顶点和集合S不连通</span><br><span class="line">if(u == -1) return -1;</span><br><span class="line">vis[u] = true;</span><br><span class="line">ans += d[u];</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] ==false &amp;&amp; G[u][v] &lt; d[v])&#123;</span><br><span class="line">d[v] = G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//邻接表</span><br><span class="line">struct Node &#123;</span><br><span class="line">int v, dis; //v为边的目标顶点，dis为边权</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; Adj[MAXV]</span><br><span class="line"></span><br><span class="line">for(int j = 0; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">int v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v</span><br><span class="line">if(vis[v] == false &amp;&amp; Adj[u][j].dis &lt; d[v]) &#123;</span><br><span class="line">d[v] = Adj[u][v].dis;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kruskal算法采用&quot;边贪心&quot;策略，步骤：</span><br><span class="line">①对所有边按边权从小到大进行排序。</span><br><span class="line">②按边权从小到大测试所有边，如果当前测试所连接的两个顶点不在同一个连通块中，</span><br><span class="line">则把这条测试边加入当前最小生成树中；否则，将边舍弃</span><br><span class="line">③执行步骤②，直到最小生成树中的边数等于总顶点数-1或是测试完所有边时结束。</span><br><span class="line">而当结束时如果最小生成树的边数小于总顶点数-1，说明该图不连通</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">int u, v;//边的两个端点编号</span><br><span class="line">int cost;//边权</span><br><span class="line">&#125;E[MAXE];</span><br><span class="line"></span><br><span class="line">int kruskal()&#123;</span><br><span class="line">令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;</span><br><span class="line">将所有边按边权从小到大排序;</span><br><span class="line">for(从小到大枚举所有边)&#123;</span><br><span class="line">if(当前测试边的两个端点在不同的连通块中) &#123;</span><br><span class="line">将该测试边加入最小生成树中;</span><br><span class="line">ans += 测试边边权;</span><br><span class="line">最小生成树的当前边数Num_Edge 加 1;</span><br><span class="line">当边数Num_Edge等于顶点数减1时结束循环;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int father[N];//并查集数组</span><br><span class="line">int findFather(int x)&#123;</span><br><span class="line">int a = x;</span><br><span class="line">while(x != father[x])</span><br><span class="line">x = father[x];</span><br><span class="line">while(a != father[a])&#123;</span><br><span class="line">int z = a;</span><br><span class="line">a = father[a];//a进行回溯</span><br><span class="line">father[z] = x;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">//n顶点数 m边数</span><br><span class="line">int kruskal(int n, int m)&#123;</span><br><span class="line">int ans = 0，Num_Edge = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(E, E + m, cmp); //所有边按边权从小到大排序</span><br><span class="line">for(int i = 0; i &lt; m; i++) &#123; //枚举所有边</span><br><span class="line">int faU = findFather(E[i].u);</span><br><span class="line">int faV = findFather(E[i].v);</span><br><span class="line">if(faU != faV) &#123; //如果不在一个集合中</span><br><span class="line">father[faU] = faV;</span><br><span class="line">ans += E[i].cost;</span><br><span class="line">Num_Edge++;</span><br><span class="line">if(Num_Edge == n - 1) break;//边数等于顶点数减1时结束算法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(Num_Edge != n - 1) return -1; //无法连通时返回-1</span><br><span class="line">else return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加油 奥利给&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://cybaol.github.io/categories/algorithm/"/>
    
    
      <category term="图论" scheme="https://cybaol.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>debug</title>
    <link href="https://cybaol.github.io/2019/10/24/warings/"/>
    <id>https://cybaol.github.io/2019/10/24/warings/</id>
    <published>2019-10-24T14:35:37.000Z</published>
    <updated>2019-11-07T11:25:16.620Z</updated>
    
    <content type="html"><![CDATA[<p>debug 之于 coder</p><a id="more"></a><p>一定一定要会debug！debug！debug！血的教训，从来都不debug的我，上课看老师debuging都不以为意,大佬们给的建议也是左耳进右耳出。花了一下午和一个晚上的时间终于把b站图标给改出来了。以后工作了面对着几千行几万行代码你能一行一行查吗？<br>还有能用框架就用框架！那效率真的不是一般的高！别傻乎乎地一行一行地去敲。</p><h1 id="发此博客引以为戒！！！"><a href="#发此博客引以为戒！！！" class="headerlink" title="发此博客引以为戒！！！"></a>发此博客引以为戒！！！</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;debug 之于 coder&lt;/p&gt;
    
    </summary>
    
    
      <category term="techs" scheme="https://cybaol.github.io/categories/techs/"/>
    
    
      <category term="警示" scheme="https://cybaol.github.io/tags/%E8%AD%A6%E7%A4%BA/"/>
    
  </entry>
  
</feed>
