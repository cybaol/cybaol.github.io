<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钱多多の博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cybaol.github.io/"/>
  <updated>2020-03-13T06:59:12.020Z</updated>
  <id>https://cybaol.github.io/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树算法</title>
    <link href="https://cybaol.github.io/2020/03/13/Tree/"/>
    <id>https://cybaol.github.io/2020/03/13/Tree/</id>
    <published>2020-03-12T23:46:00.000Z</published>
    <updated>2020-03-13T06:59:12.020Z</updated>
    
    <content type="html"><![CDATA[<p>早起的虫儿被鸟吃</p><a id="more"></a><pre><code>*二叉树的存储：链式存储和数组。*二叉树树的遍历：先序、中序、后序、层序。</code></pre><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">算法思想：</span><br><span class="line">①将根节点root加入队列q。</span><br><span class="line">②取出队首结点，访问之。</span><br><span class="line">③如果该结点有左孩子，将左孩子入队。</span><br><span class="line">④如果该结点有有孩子，将有孩子入队。</span><br><span class="line">⑤返回②，直到队列为空。</span><br><span class="line"></span><br><span class="line">void LayerOrder(node* root) &#123; //带层次</span><br><span class="line">queue&lt;node*&gt; q;</span><br><span class="line">root-&gt;layer = 1;</span><br><span class="line">q.push(root);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">node* p = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">if(p-&gt;left != NULL) &#123;</span><br><span class="line">p-&gt;left-&gt;layer = p-&gt;layer + 1;</span><br><span class="line">q.push(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">if(p-&gt;right != NULL) &#123;</span><br><span class="line">p-&gt;right-&gt;layer = p-&gt;layer + 1;</span><br><span class="line">q.push(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h1><h2 id="已知先序中序"><a href="#已知先序中序" class="headerlink" title="已知先序中序"></a>已知先序中序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">算法思想：</span><br><span class="line">①先序数组的第零个结点为根结点。</span><br><span class="line">②遍历中序数组找出根结点位置并记录。</span><br><span class="line">③计算中序数组左子树个数</span><br><span class="line">④递归建立左右子树。</span><br><span class="line"></span><br><span class="line">node* create(int preL, int preR, int inL, int inR) &#123;</span><br><span class="line">if(preL &gt; preR) return NULL;</span><br><span class="line">node* root = new node;</span><br><span class="line">root-&gt;data = pre[preL];</span><br><span class="line">int k = inL;</span><br><span class="line">for(; k &lt; inR; k++)</span><br><span class="line">if(in[k] == root-&gt;data) break;</span><br><span class="line">int numLeft = k - inL;</span><br><span class="line">root-&gt;left = create(preL + 1, preL + numLeft, inL, k - 1);</span><br><span class="line">root-&gt;right = create(preL + numLeft + 1, preR, k + 1, inR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//其他情况算法类似，重点是确定根结点和数组区间范围。</span><br></pre></td></tr></table></figure><h1 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h1><pre><code>* 左边小右边大* 对二叉查找树进行&quot;中序&quot;遍历，遍历结果是有序的</code></pre><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void search(node* root, const int x) &#123;</span><br><span class="line">if(root == NULL) &#123;</span><br><span class="line">printf(&quot;search failed!\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(x == root-&gt;data)</span><br><span class="line">printf(&quot;%d\n&quot;, root-&gt;data);</span><br><span class="line">else if(x &lt; root-&gt;data)</span><br><span class="line">search(root-&gt;left, x);</span><br><span class="line">else</span><br><span class="line">search(root-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void insert(node* &amp;root, const int x) &#123;</span><br><span class="line">if(root == NULL) &#123; //插入位置</span><br><span class="line">root = new node;</span><br><span class="line">root-&gt;data = x;</span><br><span class="line">root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(x == root-&gt;data) return; //结点已存在 直接返回</span><br><span class="line">else if(x &lt; root-&gt;data)</span><br><span class="line">insert(root-&gt;left, x);</span><br><span class="line">else</span><br><span class="line">insert(root-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的建立"><a href="#二叉查找树的建立" class="headerlink" title="二叉查找树的建立"></a>二叉查找树的建立</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node* create(int data[]) &#123;</span><br><span class="line">node* root = NULL;</span><br><span class="line">for(const auto val : data) insert(root, val);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//寻找以root为根结点的树中的最大权值结点</span><br><span class="line">node* findMAX(node* root) &#123;</span><br><span class="line">while(root-&gt;right != NULL)</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">//寻找以root为根结点的树中的最小权值结点</span><br><span class="line">node* findMin(node* root) &#123;</span><br><span class="line">while(root-&gt;left != NULL)</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">算法思想：</span><br><span class="line">①如果当前结点root为空，说明不存在权值为给定权值 直接返回。</span><br><span class="line">②如果当前结点root的权值恰为给定权值x，进入删除处理</span><br><span class="line">a)如果当前结点root不存在左右孩子，说明叶子结点，直接删除。</span><br><span class="line">b)如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然后让pre的数据覆盖root，接着在左子树中删除结点pre。</span><br><span class="line">c)如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，然后让next的数据覆盖root，接着在右子树中删除结点next。</span><br><span class="line">③如果给定的权值x小于当前结点的权值，则在左子树中递归删除权值为x的结点。</span><br><span class="line">④如果给定的权值x大于当前结点的权值，则在右子树中递归删除权值为x的结点。</span><br><span class="line"></span><br><span class="line">void deleteNode(node* root, int x) &#123;</span><br><span class="line">if(root == NULL) return; //不存在权值为x的结点</span><br><span class="line">if(x == root-&gt;data) &#123;//找到欲删除结点</span><br><span class="line">//delete(root);</span><br><span class="line">if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)</span><br><span class="line">root = NULL;</span><br><span class="line">else if(root-&gt;left != NULL) &#123;</span><br><span class="line">node* pre = findMAX(root-&gt;left, x);</span><br><span class="line">root-&gt;data = pre-&gt;data;</span><br><span class="line">deleteNode(root-&gt;left, pre-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">node* next = findMin(root-&gt;right);</span><br><span class="line">root-&gt;data = next-&gt;data;</span><br><span class="line">deleteNode(root-&gt;right, next-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if(x &lt; root-&gt;data)</span><br><span class="line">deleteNode(root-&gt;left, x);</span><br><span class="line">else</span><br><span class="line">deleteNode(root-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h1><pre><code>* AVL树是一棵二叉查找树* 任意结点的左右子树高度之差(平衡因子)的绝对值不超过1</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">int v, height;</span><br><span class="line">node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int getHeight(node* root) &#123;</span><br><span class="line">if(root == NULL) return 0;</span><br><span class="line">else return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getBalanceFactor(node* root) &#123;</span><br><span class="line">return getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateHeight(node* root) &#123;</span><br><span class="line">root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void search(node* root, const int x) &#123;</span><br><span class="line">if(root == NULL) &#123;</span><br><span class="line">printf(&quot;search failed!\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(x == root-&gt;data)</span><br><span class="line">printf(&quot;%d\n&quot;, root-&gt;data);</span><br><span class="line">else if(x &lt; root-&gt;data)</span><br><span class="line">search(root-&gt;left, x);</span><br><span class="line">else</span><br><span class="line">search(root-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//旋转问题：</span><br><span class="line">//左旋(Left Rotation)算法思想：</span><br><span class="line">①让B的左子树◆成为A的右子树</span><br><span class="line">②让A成为B的左子树</span><br><span class="line">③将根结点设定为结点B</span><br><span class="line"></span><br><span class="line">void L(node* &amp;root) &#123;</span><br><span class="line">node* p = root-&gt;right;</span><br><span class="line">root-&gt;right = p-&gt;left;</span><br><span class="line">p-&gt;left = root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(p);</span><br><span class="line">root = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右旋(Right Rotation)算法思想：</span><br><span class="line">①让A的右子树◆成为B的左子树</span><br><span class="line">②让B成为A的右子树</span><br><span class="line">③将根结点设定为结点A</span><br><span class="line"></span><br><span class="line">void R(node* &amp;root) &#123;</span><br><span class="line">node* p = root-&gt;left;</span><br><span class="line">root-&gt;left = p-&gt;right;</span><br><span class="line">p-&gt;right = root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(p);</span><br><span class="line">root = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会正常(可证明)</span><br><span class="line">//分LL型、LR型、RR型、RL型</span><br><span class="line">//LR -&gt; LL | RL -&gt; RR</span><br><span class="line">void insert(node* &amp;root, const int v) &#123;</span><br><span class="line">if(root == NULL) &#123; //插入位置</span><br><span class="line">root = new node;</span><br><span class="line">root-&gt;v = v;</span><br><span class="line">root-&gt;height = 1;</span><br><span class="line">root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(v &lt; root-&gt;v) &#123;</span><br><span class="line">insert(root-&gt;left, v);</span><br><span class="line">updateHeight(root);</span><br><span class="line">if(getBalanceFactor(root) == 2) &#123;</span><br><span class="line">if(getBalanceFactor(root-&gt;left) == 1) //LL型</span><br><span class="line">R(root);</span><br><span class="line">else if(getBalanceFactor(root-&gt;left) == -1) &#123; //LR型</span><br><span class="line">L(root-&gt;left);</span><br><span class="line">R(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">insert(root-&gt;right, v);</span><br><span class="line">updateHeight(root);</span><br><span class="line">if(getBalanceFactor(root) == -2) &#123;</span><br><span class="line">if(getBalanceFactor(root-&gt;right) == -1) //RR型</span><br><span class="line">L(root);</span><br><span class="line">else if(getBalanceFactor(root-&gt;left) == 1) &#123; //RL型</span><br><span class="line">R(root-&gt;right);</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AVL树的建立"><a href="#AVL树的建立" class="headerlink" title="AVL树的建立"></a>AVL树的建立</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node* create(int data[]) &#123;</span><br><span class="line">node* root = NULL;</span><br><span class="line">for(const auto v : data) insert(root, v);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并-Union-查-Find-集-Set"><a href="#并-Union-查-Find-集-Set" class="headerlink" title="并(Union)查(Find)集(Set)"></a>并(Union)查(Find)集(Set)</h1><pre><code>* 合并：合并两个集合* 查找：判断两个元素是否在一个集合* 并查集产生的每一个集合都是一棵树* int father[N]; //并查集数组</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt;= N; i++)</span><br><span class="line">father[i] = i;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//iterator</span><br><span class="line">int findFather(int x)&#123;</span><br><span class="line">while(x != father[x]) x = father[x];</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">//recursion</span><br><span class="line">int findFather(int x) &#123;</span><br><span class="line">if(x == father[x]) return x;</span><br><span class="line">else return findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Union(int a, int b) &#123;</span><br><span class="line">int faA = findFather(a);</span><br><span class="line">int faB = findFather(b);</span><br><span class="line">if(faA != faB)</span><br><span class="line">father[faA] = faB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">算法思想：</span><br><span class="line">①按原来的写法获得v的根结点root</span><br><span class="line">②重新从v开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点</span><br><span class="line">int findFather(int v) &#123; //T(n) = O(1)</span><br><span class="line">if(v == father[v]) return v; // 找到根结点</span><br><span class="line">else &#123;</span><br><span class="line">//让当前结点v的父亲全部改为根结点</span><br><span class="line">int root = findFather(father[v]);</span><br><span class="line">father[v] = root;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆-heap-与堆排序"><a href="#堆-heap-与堆排序" class="headerlink" title="堆(heap)与堆排序"></a>堆(heap)与堆排序</h1><pre><code>* 堆是一个完全二叉树* 大顶堆 和 小顶堆* 堆可以用来实现优先队列* int heap[maxn], n; // n为元素个数</code></pre><h2 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//向下调整 T(n) = O(logn)</span><br><span class="line">//其中low为欲调整的数组下表，high一般为堆的最后一个元素的数组下标</span><br><span class="line">void downAdjust(int low, int high) &#123;</span><br><span class="line">int i = low, j = i * 2;</span><br><span class="line">while(j &lt;= high) &#123;</span><br><span class="line">if(j + 1 &lt;= high &amp;&amp; heap[j+1] &gt; heap[j])</span><br><span class="line">j = j + 1;</span><br><span class="line">if(heap[j] &gt; heap[i]) &#123;</span><br><span class="line">swap(heap[j], heap[i]);</span><br><span class="line">i = j;</span><br><span class="line">j = i * 2;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//从最后一名同学位置开始，从下往上 从右往左</span><br><span class="line">//左轮·D·普拉西多</span><br><span class="line">// T(n) = O(n)</span><br><span class="line">void createHeap() &#123;</span><br><span class="line">for (int i = n / 2; i &gt;= 1; i--) &#123;</span><br><span class="line">downAdjust(i, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除堆顶"><a href="#删除堆顶" class="headerlink" title="删除堆顶"></a>删除堆顶</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// T(n) = O(n)</span><br><span class="line">void deleteTop()&#123;</span><br><span class="line">heap[1] = heap[n--]; //用最后一个元素覆盖堆顶元素，并让元素个数减1</span><br><span class="line">downAdjust(1,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向上调整"><a href="#向上调整" class="headerlink" title="向上调整"></a>向上调整</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// T(n) = O(logn)</span><br><span class="line">void upAdjust(int low, int high) &#123;</span><br><span class="line">int i = high, j = i / 2;</span><br><span class="line">while(j &gt;= low)&#123;</span><br><span class="line">if(heap[i] &gt; heap[j])&#123;</span><br><span class="line">swap(heap[i], heap[j]);</span><br><span class="line">i = j;</span><br><span class="line">j = i / 2;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void insert(node* root, int x) &#123;</span><br><span class="line">heap[++n] = x; // 加入到堆最后一个元素后面，并让元素个数加1</span><br><span class="line">upAdjust(1, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序-heap-sort"><a href="#堆排序-heap-sort" class="headerlink" title="堆排序(heap sort)"></a>堆排序(heap sort)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void heapSort() &#123;</span><br><span class="line">createHeap();</span><br><span class="line">for (int i = n; i &gt; 1; i--)&#123;</span><br><span class="line">swap(heap[1], heap[i]);</span><br><span class="line">downAdjust(1,i - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//算法思想：</span><br><span class="line">//反复选择两个最小的元素，合并，直到只剩下一个元素</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">long long temp, x, y, ans = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;temp);</span><br><span class="line">q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">while(q.size() &gt; 1) &#123;</span><br><span class="line">x = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">y = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">q.push(x + y);</span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早起的虫儿被鸟吃&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://cybaol.github.io/categories/algorithm/"/>
    
    
      <category term="树" scheme="https://cybaol.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Be a magical developer</title>
    <link href="https://cybaol.github.io/2019/11/19/ambition/"/>
    <id>https://cybaol.github.io/2019/11/19/ambition/</id>
    <published>2019-11-19T15:15:37.000Z</published>
    <updated>2019-11-19T16:47:20.318Z</updated>
    
    <content type="html"><![CDATA[<p>《一百种自杀方法》最后一页写着活下去。</p><a id="more"></a><ul><li><a href="https://www.choupangxia.com/2019/09/26/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/" target="_blank" rel="noopener">费曼学习法</a>  </li><li>康奈尔笔记  </li><li>计算机组成原理(秃头程序员的进阶感觉可还行)(<a href="https://www.bilibili.com/video/av15123338" target="_blank" rel="noopener">哈工大</a>)  </li><li>数据结构与算法(不C9 无算法 一直都坚信它是程序的灵魂 加油)(<a href="https://www.bilibili.com/video/av7134874" target="_blank" rel="noopener">北大</a>+<a href="https://www.bilibili.com/video/av49361421" target="_blank" rel="noopener">清华</a>+算法导论原书第三版)  </li><li>操作系统(听说过bug10吧) (<a href="https://www.bilibili.com/video/av6538245" target="_blank" rel="noopener">北大</a>)  </li><li>计算机网络(学好卖网线)(<a href="./计算机网络原理：自顶向下方法（第6版）.pdf">自顶而下英文原版</a>)  </li><li>编译原理(<a href="https://www.bilibili.com/video/av17649289" target="_blank" rel="noopener">哈工大</a>)</li><li>嵌入式系统(<a href="https://www.bilibili.com/video/av29287517" target="_blank" rel="noopener">清华</a>)</li><li>信息论与编码（<a href="https://www.bilibili.com/video/av28661250" target="_blank" rel="noopener">清华</a>+<a href="https://www.bilibili.com/video/av26735580" target="_blank" rel="noopener">西电</a>）</li><li><a href="https://www.bilibili.com/video/av9912938" target="_blank" rel="noopener">机器学习</a>  </li><li>前端  </li><li>数据库  </li><li>健身  </li><li>个人札记  <ol><li>学点经济学</li><li>为竞赛而生  </li><li>多看英文原版书  </li><li>多线程+设计模式  </li><li>多看项目源码  </li><li>脚踏实地的理想主义者，既要有高远的理想也要有脚踏实地的精神  </li><li>他们只是起点比我们高 – 2018-10-3 打卡南京大学鼓楼校区  </li><li>见见有趣的人，读读有趣的书，讲讲有趣的故事。  </li><li>有时候我们会觉得自己后知后觉，那是因为学习的太少，了解的太少，很多问题前人已经总结好了现成的方法和方案，我们却不知道，还在自己探索，当然行动缓慢，后知后觉了。只有站在巨人的肩膀上才能看得更远。   </li><li>2019-10-26打卡东南大学四牌楼校区图书馆  </li><li>备战华北电力大学计算机专硕（<a href="./华北电力大学2020专业课大纲.doc">844数据结构</a>）  </li><li><a href="https://app.yinxiang.com/shard/s40/nl/24222849/82d590e6-3c3b-4af1-87c2-8964f41501e9/" target="_blank" rel="noopener">C语言笔记</a>  </li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《一百种自杀方法》最后一页写着活下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="techs" scheme="https://cybaol.github.io/categories/techs/"/>
    
    
      <category term="成长" scheme="https://cybaol.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>大学阅读记录</title>
    <link href="https://cybaol.github.io/2019/11/07/book/"/>
    <id>https://cybaol.github.io/2019/11/07/book/</id>
    <published>2019-11-07T11:32:37.000Z</published>
    <updated>2020-03-12T02:02:09.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./20191120135008.jpg" alt="一起努力(劝退)"></p><a id="more"></a><h2 id="1-算法类"><a href="#1-算法类" class="headerlink" title="1. 算法类"></a>1. 算法类</h2><p>花费我时间最长的东西 不放在第一位都觉得对不起自己.  </p><ul><li>算法导论  </li><li>大话数据结构  </li><li>算法笔记  </li><li>算法笔记上机训练实战指南    </li><li>算法之美  </li><li>初等数论  </li><li>啊哈算法   </li><li>算法竞赛入门经典（第2版）  </li><li>算法竞赛入门经典训练指南  </li><li>大学生程序设计课程与竞赛训练教材-算法设计编程实验 <h2 id="2-语言类杂书"><a href="#2-语言类杂书" class="headerlink" title="2. 语言类杂书"></a>2. 语言类杂书</h2>同类书籍看了一堆又一堆 就觉得这几本有点意思(索然无味).  </li><li>C Traps and Pitfalls   </li><li>Expert C Programming  </li><li>C Pointer  </li><li>C++ STL  </li><li>C++ 11 新标准  </li><li>C++ 编程思想  </li><li>Effective C++  </li><li>More Effective C++  </li><li>Computer Network A Top-Down Approach  </li><li>CSAPP<h2 id="3-Python小爬虫"><a href="#3-Python小爬虫" class="headerlink" title="3. Python小爬虫"></a>3. Python小爬虫</h2>骚不动系列，只看了一本两个晚上93分过期末。。。  </li><li>Python编程:从入门到实践  <h2 id="4-程序人生"><a href="#4-程序人生" class="headerlink" title="4. 程序人生"></a>4. 程序人生</h2></li><li>数学之美</li><li>浪潮之巅  <h2 id="5-人文社科类"><a href="#5-人文社科类" class="headerlink" title="5. 人文社科类"></a>5. 人文社科类</h2></li><li>愿你与这世界温暖相拥</li><li>一寸一寸暖你</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./20191120135008.jpg&quot; alt=&quot;一起努力(劝退)&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="books" scheme="https://cybaol.github.io/categories/books/"/>
    
    
      <category term="阅读" scheme="https://cybaol.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>图论算法</title>
    <link href="https://cybaol.github.io/2019/11/01/Graph/"/>
    <id>https://cybaol.github.io/2019/11/01/Graph/</id>
    <published>2019-11-01T03:00:37.000Z</published>
    <updated>2020-03-12T15:54:37.991Z</updated>
    
    <content type="html"><![CDATA[<p>奥利给</p><a id="more"></a><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><pre><code>* 有两种存储方式：邻接矩阵和邻接表* 在一些顶点数目比较大（一般顶点个数在1000以上）的情况下，使用邻接表而  不是邻接矩阵来存储图。如果是稀疏图，用邻接表，如果是稠密图，用邻接矩阵。</code></pre><h2 id="深度优先搜索dfs遍历图"><a href="#深度优先搜索dfs遍历图" class="headerlink" title="深度优先搜索dfs遍历图"></a>深度优先搜索dfs遍历图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//按深度优先的方式访问所有未被访问的结点，在结点被访问过后标记为已访问</span><br><span class="line">dfs(u) &#123;</span><br><span class="line">  vis[u] = true;</span><br><span class="line">  for(从u出发到能到达的所有顶点v)</span><br><span class="line">    if(vis[v] == false)</span><br><span class="line">      dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">dfsTrave(G) &#123;</span><br><span class="line">  for(G的所有顶点u)</span><br><span class="line">    if(vis[u] == false)</span><br><span class="line">      dfs(u); //访问u所在连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵版 DFS</span><br><span class="line"></span><br><span class="line">int n, G[maxV][maxV];//n顶点数 maxV最大顶点数</span><br><span class="line">bool vis[maxV] = &#123;false&#125;;//记录顶点是否被访问过</span><br><span class="line"></span><br><span class="line">void dfs(int u, int depth) &#123;</span><br><span class="line">    vis[u] = true;</span><br><span class="line">    for(int v = 0; v &lt; n; v++)//遍历u可以到达的顶点v</span><br><span class="line">        if(G[u][v] != INF &amp;&amp; vis[v] == false)</span><br><span class="line">            dfs(v, depth + 1);//访问v 深度+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void travelDFS() &#123;</span><br><span class="line">    for(int u = 0; u &lt; n; u++)</span><br><span class="line">        if(vis[u] == false)</span><br><span class="line">            dfs(u, 1);//访问u和u所在的连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//邻接表版 DFS</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; arr[maxn];</span><br><span class="line"></span><br><span class="line">void dfs(int u, int depth) &#123;</span><br><span class="line">  vis[u] = true;</span><br><span class="line">  for(int i = 0; i &lt; arr[u].size(); i++)&#123;</span><br><span class="line">int v = arr[u][i];</span><br><span class="line">if(vis[i] == false)</span><br><span class="line">    dfs(v, depth + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfsTrave() &#123;</span><br><span class="line">  for(int u = 0; u &lt; n; u++) &#123;</span><br><span class="line">    if(vis[u] == false)</span><br><span class="line">      dfs(u, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs遍历图"><a href="#广度优先搜索bfs遍历图" class="headerlink" title="广度优先搜索bfs遍历图"></a>广度优先搜索bfs遍历图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//建立一个队列，把初始定点加入队列，然后每次都取出队首元素进行访问，并把该定点  </span><br><span class="line">//除法可以到达的未曾加入过队列（而不是未访问）的顶点全部加入队列，直到队列为空。</span><br><span class="line">bfs(u) &#123;</span><br><span class="line">  queue q;</span><br><span class="line">  将u入队</span><br><span class="line">  inq[u] = true;</span><br><span class="line">  while(q非空) &#123;</span><br><span class="line">    for(从u出发到可到达的所有顶点v) &#123;</span><br><span class="line">      if(inq[v] == false)</span><br><span class="line">        将v入队</span><br><span class="line">        inq[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfsTrave(G) &#123;</span><br><span class="line">  for(G的所有顶点u) &#123;</span><br><span class="line">    if(inq[u] == false)</span><br><span class="line">      bfs(u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵版 BFS</span><br><span class="line">int n, G[maxV][maxV];//n顶点数 maxV最大顶点数</span><br><span class="line">bool inq[maxV] = &#123;false&#125;;//记录顶点的是否入队</span><br><span class="line"></span><br><span class="line">void bfs(int u) &#123;//u顶点编号</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(u);//入队</span><br><span class="line">inq[u] = true;</span><br><span class="line">while(!q.empty()) &#123;</span><br><span class="line">int u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int v = 0; v &lt; n; v++)//遍历u所在连通块（未入队）并入队</span><br><span class="line">if(G[u][v] != INF &amp;&amp; inq[v] == false)&#123;</span><br><span class="line">q.push(v);、</span><br><span class="line">inq[v] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*邻接表：</span><br><span class="line">for(int i = 0; i &lt; arr[u].size(); i++) &#123;</span><br><span class="line">  int v= arr[u][i];</span><br><span class="line">  if(inq[v] == false) &#123;</span><br><span class="line">    q.push(v);</span><br><span class="line">    inq[v] = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void travelBFS() &#123;</span><br><span class="line">for(int v = 0; v &lt; n; v++)</span><br><span class="line">if (inq[v] == false)</span><br><span class="line">bfs(v);//遍历v及其所在连通块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//带层数的 邻接表</span><br><span class="line">struct node &#123;</span><br><span class="line">  int v;//顶点编号</span><br><span class="line">  int layer;//顶点层号</span><br><span class="line">&#125;;</span><br><span class="line">next.layer = curNode.layer + 1;</span><br><span class="line">//邻接表中的类型是node，而不是int</span><br><span class="line">vector&lt;node&gt; Adj[N];</span><br></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><pre><code>单源最短路径：计算源点到其他各顶点的最短路径的长度全局最短路径：图中任意两点的最短路径Dijkstra、Bellman-Ford、SPFA求单源最短路径Floyd可以求全局最短路径，但是效率比较低SPFA算法是Bellman-Ford算法的队列优化Dijkstra算法不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径。Bellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行。深度优先遍历可以求一个点到另一个点的最短路径的长度</code></pre><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><pre><code>思想来源：图的广度优先遍历bfs</code></pre><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra 算法：</span><br><span class="line">//对图G(V,E)设置集合S，存放已被访问的顶点，</span><br><span class="line">//然后每次从集合V-S中选择与起点s的最短距离最小的一个顶点(记为u),访问并加入集合S，</span><br><span class="line">//之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v的最短距离，</span><br><span class="line">//这样的操作执行n次,直到集合S已包含所有顶点。</span><br><span class="line"></span><br><span class="line">int G[maxSize][maxSize], n;</span><br><span class="line">int d[maxSize];</span><br><span class="line">int pre[maxSize];</span><br><span class="line">bool vis[maxSize] = &#123;false&#125;;</span><br><span class="line">//邻接矩阵</span><br><span class="line">void Dijkstra(int s) &#123; //T(n) = O(V^2)</span><br><span class="line">fill(d, d + maxSize, INF);</span><br><span class="line">d[s] = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">int u = -1, min = INF;//u 保存最短路径顶点，min保存最短距离</span><br><span class="line">for (int j = 0; j &lt; n; j++)</span><br><span class="line">if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123;</span><br><span class="line">u = j;</span><br><span class="line">min = d[j];</span><br><span class="line">&#125;</span><br><span class="line">//找不到小于INF的d[u]，说明剩下的顶点与起点s不连通</span><br><span class="line">if(u == -1) return;</span><br><span class="line">vis[u] = true;</span><br><span class="line">for (int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">//以u为中介点使可以使d[v]更优</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">pre[v] = u; //记录v的前驱结点u</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//邻接表</span><br><span class="line">struct Node &#123;</span><br><span class="line">int v, dis; //v为边的目标顶点，dis为边权</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; Adj[MAXV]</span><br><span class="line"></span><br><span class="line">for(int j = 0; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">int v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v</span><br><span class="line">if(vis[v] == false &amp;&amp; d[u] + Adj[u][v].dis &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + Adj[u][v].dis;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//无向图解决方案: 把无向边当成指向相反的有向边</span><br><span class="line"></span><br><span class="line">void DFS(int s, int v) &#123;//s起点编号，v是当前访问的顶点编号（从终点开始递归）</span><br><span class="line">if(v == s) &#123; //如果当前已经打扫起点s，则输出起点并返回</span><br><span class="line">printf(&quot;%d\n&quot;, s);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">DFS(s, pre[v]); //递归访问v的前驱结点pre[v]</span><br><span class="line">printf(&quot;%d\n&quot;, v);//从最深处return回来之后，输出每一层的顶点号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>附加考法：第一标尺是距离，第二标尺常见有三种①新增边权：给每条边再增加一个边权（比如花费），然后要求在最短路径有多条时要求路径上的花费之和最小（如果边权是其它含义，也可以是最大）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//c[] 从起点s到达顶点u的最少花费c[u]</span><br><span class="line">//cost[u][v]表示u-&gt;v的花费</span><br><span class="line">//初始化时只有c[s] = 0 其余均为INF</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">c[v] = c[u] +cost[u][v];</span><br><span class="line">&#125;else if(d[u] + G[u][v] == d[v] &amp;&amp; c[u] +cost[u][v] &lt; c[v])&#123;</span><br><span class="line">c[v] = c[u] +cost[u][v];//最短距离相同时，看c[v]能否更优</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>②新增点权：给每个点增加一个点权（例如每个城市能收集到的物资），然后在最短路径有多条时要求路径上的点权之和最大（如果点权是其它含义也可以是最小）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//w[]从起点s到顶点u能收集的最大物资w[u]</span><br><span class="line">//weight[u]表示城市u中的物资数目 即即将运送的物资</span><br><span class="line">//初始化时只有w[s]为weight[u] 其余均为0</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">w[v] = w[u] + weight[v];</span><br><span class="line">&#125;</span><br><span class="line">else if(d[u] + G[u][v] == d[v] &amp;&amp; w[u] + weight[v] &gt; w[v])&#123;</span><br><span class="line">w[v] = w[u] + weight[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>③直接问有多少条最短路径</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//num[]从起点s到达顶点u的最短路径条数为num[u]</span><br><span class="line">//初始化只有num[s] = 1 其余均为0</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] == false) &#123;</span><br><span class="line">if(d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">num[v] = num[u];</span><br><span class="line">&#125;</span><br><span class="line">else if(d[u] + G[u][v] == d[v])&#123;</span><br><span class="line">num[v] += num[u];//最短距离相同时累加num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全源最短路径"><a href="#全源最短路径" class="headerlink" title="全源最短路径"></a>全源最短路径</h2><h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Floyd算法</span><br><span class="line">枚举顶点 k ∈ [1,n]</span><br><span class="line">以顶点 k 作为中介点，枚举所有顶点对i和j （i，j∈ [1,n]）</span><br><span class="line">如果dis[i][k] + dis[k][j] &lt; dis[i][j]成立</span><br><span class="line">赋值dis[i][j] = dis[i][k] + dis[k][j]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int n, m; //n顶点数， m为边数</span><br><span class="line">int dis[MAXV][MAXV]; //dis[i][j]表示顶点i和j的最短距离</span><br><span class="line"></span><br><span class="line">void Floyd()&#123;</span><br><span class="line">for(int k = 0; k &lt; n; k++) &#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">if(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])</span><br><span class="line">dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><pre><code>如果是稠密图(边多) prim算法如果是稀疏图(边少) kruskal算法</code></pre><h2 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prim算法：</span><br><span class="line">//对图G(V,E)设置集合S，存放已被访问的顶点，</span><br><span class="line">//然后每次从集合V-S中选择与集合S的最短距离最小的一个顶点（记为u）访问并加入集合S。</span><br><span class="line">//之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。</span><br><span class="line">//这样执行操作n次（n为顶点个数），直到集合S已包含所有顶点。</span><br><span class="line">//prim算法和Dijkstra算法只有优化d[v]部分不同</span><br><span class="line">//prim算法和Dijkstra算法思路完全相同，只不过是数组d[]含义不同</span><br><span class="line">Prim(G, d[])&#123;</span><br><span class="line">初始化</span><br><span class="line">for(循环n次)&#123;</span><br><span class="line">u = 使d[u]最小的还未被访问的顶点的标号</span><br><span class="line">for(从u除法能到达的所有顶点)&#123;</span><br><span class="line">if(v未被访问&amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)&#123;</span><br><span class="line">将G[u][v]赋值给v与集合S的最短距离d[v]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//邻接矩阵</span><br><span class="line">int n, G[MAXV][MAXV]; //n为顶点数</span><br><span class="line">int d[MAXV]; //顶点与集合S的最短距离</span><br><span class="line">bool vis[MAXV] = &#123;false&#125;; //标记数组，vis[i] == true表示已访问。初值均为false</span><br><span class="line"></span><br><span class="line">int prim()&#123;//默认0号为初始点</span><br><span class="line">fill(d, d + MAXV, INF);</span><br><span class="line">d[0] = 0;</span><br><span class="line">int ans = 0; //存放最小生成树的边权之和</span><br><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">int u = -1, min = INF; //u使d[u]最小，min存放该最小的d[u]</span><br><span class="line">for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123;</span><br><span class="line">u = j;</span><br><span class="line">min = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//找不到小于INF的d[u]，则剩下的顶点和集合S不连通</span><br><span class="line">if(u == -1) return -1;</span><br><span class="line">vis[u] = true;</span><br><span class="line">ans += d[u];</span><br><span class="line">for(int v = 0; v &lt; n; v++) &#123;</span><br><span class="line">if(G[u][v] != INF &amp;&amp; vis[v] ==false &amp;&amp; G[u][v] &lt; d[v])&#123;</span><br><span class="line">d[v] = G[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//邻接表</span><br><span class="line">struct Node &#123;</span><br><span class="line">int v, dis; //v为边的目标顶点，dis为边权</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; Adj[MAXV]</span><br><span class="line"></span><br><span class="line">for(int j = 0; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">int v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v</span><br><span class="line">if(vis[v] == false &amp;&amp; Adj[u][j].dis &lt; d[v]) &#123;</span><br><span class="line">d[v] = Adj[u][v].dis;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kruskal算法采用&quot;边贪心&quot;策略，步骤：</span><br><span class="line">①对所有边按边权从小到大进行排序。</span><br><span class="line">②按边权从小到大测试所有边，如果当前测试所连接的两个顶点不在同一个连通块中，</span><br><span class="line">则把这条测试边加入当前最小生成树中；否则，将边舍弃</span><br><span class="line">③执行步骤②，直到最小生成树中的边数等于总顶点数-1或是测试完所有边时结束。</span><br><span class="line">而当结束时如果最小生成树的边数小于总顶点数-1，说明该图不连通</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">int u, v;//边的两个端点编号</span><br><span class="line">int cost;//边权</span><br><span class="line">&#125;E[MAXE];</span><br><span class="line"></span><br><span class="line">int kruskal()&#123;</span><br><span class="line">令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;</span><br><span class="line">将所有边按边权从小到大排序;</span><br><span class="line">for(从小到大枚举所有边)&#123;</span><br><span class="line">if(当前测试边的两个端点在不同的连通块中) &#123;</span><br><span class="line">将该测试边加入最小生成树中;</span><br><span class="line">ans += 测试边边权;</span><br><span class="line">最小生成树的当前边数Num_Edge 加 1;</span><br><span class="line">当边数Num_Edge等于顶点数减1时结束循环;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int father[N];//并查集数组</span><br><span class="line">int findFather(int x)&#123;</span><br><span class="line">while(x != father[x]) x = father[x];</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">//n顶点数 m边数</span><br><span class="line">int kruskal(int n, int m)&#123;</span><br><span class="line">int ans = 0，Num_Edge = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(E, E + m, cmp); //所有边按边权从小到大排序</span><br><span class="line">for(int i = 0; i &lt; m; i++) &#123; //枚举所有边</span><br><span class="line">int faU = findFather(E[i].u);</span><br><span class="line">int faV = findFather(E[i].v);</span><br><span class="line">if(faU != faV) &#123; //如果不在一个集合中</span><br><span class="line">father[faU] = faV;</span><br><span class="line">ans += E[i].cost;</span><br><span class="line">Num_Edge++;</span><br><span class="line">if(Num_Edge == n - 1) break;//边数等于顶点数减1时结束算法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(Num_Edge != n - 1) return -1; //无法连通时返回-1</span><br><span class="line">else return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;奥利给&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://cybaol.github.io/categories/algorithm/"/>
    
    
      <category term="图论" scheme="https://cybaol.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>debug</title>
    <link href="https://cybaol.github.io/2019/10/24/warings/"/>
    <id>https://cybaol.github.io/2019/10/24/warings/</id>
    <published>2019-10-24T14:35:37.000Z</published>
    <updated>2019-11-07T11:25:16.620Z</updated>
    
    <content type="html"><![CDATA[<p>debug 之于 coder</p><a id="more"></a><p>一定一定要会debug！debug！debug！血的教训，从来都不debug的我，上课看老师debuging都不以为意,大佬们给的建议也是左耳进右耳出。花了一下午和一个晚上的时间终于把b站图标给改出来了。以后工作了面对着几千行几万行代码你能一行一行查吗？<br>还有能用框架就用框架！那效率真的不是一般的高！别傻乎乎地一行一行地去敲。</p><h1 id="发此博客引以为戒！！！"><a href="#发此博客引以为戒！！！" class="headerlink" title="发此博客引以为戒！！！"></a>发此博客引以为戒！！！</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;debug 之于 coder&lt;/p&gt;
    
    </summary>
    
    
      <category term="techs" scheme="https://cybaol.github.io/categories/techs/"/>
    
    
      <category term="警示" scheme="https://cybaol.github.io/tags/%E8%AD%A6%E7%A4%BA/"/>
    
  </entry>
  
</feed>
