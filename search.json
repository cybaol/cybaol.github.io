[{"title":"Be a magical developer","url":"/2019/11/19/ambition/","content":"《一百种自杀方法》最后一页写着活下去。\n<!-- more -->\n\n* [费曼学习法](https://www.choupangxia.com/2019/09/26/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/)  \n* 康奈尔笔记  \n* 计算机组成原理(秃头程序员的进阶感觉可还行)([哈工大](https://www.bilibili.com/video/av15123338))  \n* 数据结构与算法(不C9 无算法 一直都坚信它是程序的灵魂 加油)([北大](https://www.bilibili.com/video/av7134874)+[清华](https://www.bilibili.com/video/av49361421)+算法导论原书第三版)  \n* 操作系统(听说过bug10吧) ([北大](https://www.bilibili.com/video/av6538245))  \n* 计算机网络(学好卖网线)([自顶而下英文原版](./计算机网络原理：自顶向下方法（第6版）.pdf))  \n* 编译原理([哈工大](https://www.bilibili.com/video/av17649289))\n* 嵌入式系统([清华](https://www.bilibili.com/video/av29287517))\n* 信息论与编码（[清华](https://www.bilibili.com/video/av28661250)+[西电](https://www.bilibili.com/video/av26735580)）\n* [机器学习](https://www.bilibili.com/video/av9912938)  \n* 前端  \n* 数据库  \n* 健身  \n* 个人札记  \n    1. 学点经济学\n\t2. 为竞赛而生  \n\t3. 多看英文原版书  \n\t4. 多线程+设计模式  \n\t5. 多看项目源码  \n\t6. 脚踏实地的理想主义者，既要有高远的理想也要有脚踏实地的精神  \n\t7. 他们只是起点比我们高 -- 2018-10-3 打卡南京大学鼓楼校区  \n\t8. 见见有趣的人，读读有趣的书，讲讲有趣的故事。  \n\t9. 有时候我们会觉得自己后知后觉，那是因为学习的太少，了解的太少，很多问题前人已经总结好了现成的方法和方案，我们却不知道，还在自己探索，当然行动缓慢，后知后觉了。只有站在巨人的肩膀上才能看得更远。   \n\t10. 2019-10-26打卡东南大学四牌楼校区图书馆  \n\t11. 备战华北电力大学计算机专硕（[844数据结构](./华北电力大学2020专业课大纲.doc)）  \n\t12. [C语言笔记](https://app.yinxiang.com/shard/s40/nl/24222849/82d590e6-3c3b-4af1-87c2-8964f41501e9/)  \n","tags":["成长"],"categories":["techs"]},{"title":"大学阅读记录","url":"/2019/11/07/book/","content":"\n![一起努力(劝退)](./20191120135008.jpg)\n\n<!-- more -->\n\n## 1. 算法类\n花费我时间最长的东西 不放在第一位都觉得对不起自己.  \n* 算法导论  \n* 大话数据结构  \n* 算法笔记  \n* 算法笔记上机训练实战指南    \n* 算法之美  \n* 初等数论  \n* 啊哈算法   \n* 算法竞赛入门经典（第2版）  \n* 算法竞赛入门经典训练指南  \n* 大学生程序设计课程与竞赛训练教材-算法设计编程实验 \n## 2. 语言类杂书\n同类书籍看了一堆又一堆 就觉得这几本有点意思(索然无味).  \n* C Traps and Pitfalls   \n* Expert C Programming  \n* C Pointer  \n* C++ STL  \n* C++ 11 新标准  \n* C++ 编程思想  \n* Effective C++  \n* More Effective C++  \n* Computer Network A Top-Down Approach  \n* CSAPP\n## 3. Python小爬虫\n骚不动系列，只看了一本两个晚上93分过期末。。。  \n* Python编程:从入门到实践  \n## 4. 程序人生\n* 数学之美\n* 浪潮之巅  \n## 5. 人文社科类\n* 愿你与这世界温暖相拥\n* 一寸一寸暖你","tags":["阅读"],"categories":["books"]},{"title":"图论算法","url":"/2019/11/01/Graph/","content":"\n加油 奥利给\n\n<!-- more -->\n# 图的遍历\n    * 有两种存储方式：邻接矩阵和邻接表\n    * 在一些顶点数目比较大（一般顶点个数在1000以上）的情况下，使用邻接表而  \n    不是邻接矩阵来存储图。如果是稀疏图，用邻接表，如果是稠密图，用邻接矩阵。\n\n## 深度优先搜索dfs遍历图\n* 按深度优先的方式访问所有未被访问的结点，在结点被访问过后标记为已访问\n```\ndfs(u) {\n  vis[u] = true;\n  for(从u出发到能到达的所有顶点v)\n    if(vis[v] == false)\n      dfs(v);\n}\ndfsTrave(G) {\n  for(G的所有顶点u)\n    if(vis[u] == false)\n      dfs(u); //访问u所在连通块\n}\n```\n\n```  \n//邻接矩阵版 DFS\n\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool vis[maxV] = {false};//记录顶点是否被访问过\n\nvoid dfs(int u, int depth) {\n    vis[u] = true;\n    for(int v = 0; v < n; v++)//遍历u可以到达的顶点v\n        if(G[u][v] != INF && vis[v] == false)\n            dfs(v, depth + 1);//访问v 深度+1\n}\n\nvoid travelDFS() {\n    for(int u = 0; u < n; u++)\n        if(vis[u] == false)\n            dfs(u, 1);//访问u和u所在的连通块\n}```\n```\n//邻接表版 DFS\n\nvector<int> arr[maxn];\n\nvoid dfs(int u, int depth) {\n  vis[u] = true;\n  for(int i = 0; i < arr[u].size(); i++){\n\tint v = arr[u][i];\n\tif(vis[i] == false)\n    \tdfs(v, depth + 1);\n  }\n}\n\nvoid dfsTrave() {\n  for(int u = 0; u < n; u++) {\n    if(vis[u] == false)\n      dfs(u, 1);\n  }\n}\n```\n## 广度优先搜索bfs遍历图\n* 建立一个队列，把初始定点加入队列，然后每次都取出队首元素进行访问，并把该定点  \n除法可以到达的未曾加入过队列（而不是未访问）的顶点全部加入队列，直到队列为空。\n```\nbfs(u) {\n  queue q;\n  将u入队\n  inq[u] = true;\n  while(q非空) {\n    for(从u出发到可到达的所有顶点v) {\n      if(inq[v] == false)\n        将v入队\n        inq[v] = true;\n    }\n  }\n}\n\nbfsTrave(G) {\n  for(G的所有顶点u) {\n    if(inq[u] == false)\n      bfs(u);\n  }\n}\n```\n\n```\n//邻接矩阵版 BFS\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool inq[maxV] = {false};//记录顶点的是否入队\n\nvoid bfs(int u) {//u顶点编号\n\tqueue<int> q;\n\tq.push(u);//入队\n\tinq[u] = true;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int v = 0; v < n; ++v)//遍历u所在连通块（未入队）并入队\n\t\t\tif(G[u][v] != INF && inq[v] == false){\n\t\t\t\tq.push(v);、\n\t\t\t\tinq[v] = true;\n\t\t\t}\n\t}\n}\n\n/*邻接表：\nfor(int i = 0; i < arr[u].size(); i++) {\n  int v= arr[u][i];\n  if(inq[v] == false) {\n    q.push(v);\n    inq[v] = true;\n  }\n}\n*/\n\nvoid travelBFS() {\n\tfor(int v = 0; v < n; ++v)\n\t\tif (inq[v] == false)\n\t\t\tbfs(v);//遍历v及其所在连通块\n}```\n\n```\n//带层数的 邻接表\nstruct node {\n  int v;//顶点编号\n  int layer;//顶点层号\n};\nnext.layer = curNode.layer + 1;\n//邻接表中的类型是node，而不是int\nvector<node> Adj[N];\n```\n# 最短路径\n\t单源最短路径：计算源点到其他各顶点的最短路径的长度\n\t全局最短路径：图中任意两点的最短路径\n\tDijkstra、Bellman-Ford、SPFA求单源最短路径\n\tFloyd可以求全局最短路径，但是效率比较低\n\tSPFA算法是Bellman-Ford算法的队列优化\n\tDijkstra算法不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径。\n\tBellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行。\n\t深度优先遍历可以求一个点到另一个点的最短路径的长度\n## 单源最短路径\n\t思想来源：图的广度优先遍历bfs\n### Dijkstra 算法\n```\nint G[maxSize][maxSize], n;\nint d[maxSize];\nint pre[maxSize];\nbool vis[maxSize] = {false};\n//邻接矩阵\nvoid Dijkstra(int s) { //T(n) = O(V^2)\n\tfill(d, d + maxSize, INF);\n\td[s] = 0;\n\tfor (int i = 0; i < n; ++i){\n\t\tint u = -1, min = INF;//u 保存最短路径顶点，min保存最短距离\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif(vis[j] == false && d[j] < min) {\n\t\t\t\tu = j;\n\t\t\t\tmin = d[j];\n\t\t\t}\n\t\t//找不到小于INF的d[u]，说明剩下的顶点与起点s不连通\n\t\tif(u == -1) return;\n\t\tvis[u] = true;\n\t\tfor (int v = 0; v< n; ++v) {\n\t\t\t//以u为中介点使可以使d[v]更优\n\t\t\tif(G[u][v] != INF && vis[v] == false && d[u] + G[u][v] < d[v]) {\n\t\t\t\td[v] = d[u] + G[u][v];\n\t\t\t\tpre[v] = u; //记录v的前驱结点u\n\t\t\t}\n\t\t}\n\t}\n}\n```\n```\n//邻接表\nstruct Node {\n\tint v, dis; //v为边的目标顶点，dis为边权\n};\n\nvector<Node> Adj[MAXV]\n\nfor(int j = 0; j < Adj[u].size(); j++) {\n\tint v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v\n\tif(vis[v] == false && d[u] + Adj[u][v].dis < d[v]) {\n\t\td[v] = d[u] + Adj[u][v].dis;\n\t} \n}\n\n\n```\n\n```\n//无向图解决方案: 把无向边当成指向相反的有向边\n\nvoid DFS(int s, int v) {//s起点编号，v是当前访问的顶点编号（从终点开始递归）\n\tif(v == s) { //如果当前已经打扫起点s，则输出起点并返回\n\t\tprintf(\"%d\\n\", s);\n\t\treturn;\n\t}\n\tDFS(s, pre[v]); //递归访问v的前驱结点pre[v]\n\tprintf(\"%d\\n\", v);//从最深处return回来之后，输出每一层的顶点号\n}\n```\n\t附加考法：第一标尺是距离，第二标尺常见有三种\n\t①新增边权：给每条边再增加一个边权（比如花费），然后要求在最短路径有多条时要求路径上的花费之和最小（如果边权是其它含义，也可以是最大）。\n```\n//c[] 从起点s到达顶点u的最少花费c[u]\n//cost[u][v]表示u->v的花费\n//初始化时只有c[s] = 0 其余均为INF\nfor(int v; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tc[v] = c[u] +cost[u][v];\n\t\t}else if(d[u] + G[u][v] == d[v] && c[u] +cost[u][v] < c[v]){\n\t\t\t\tc[v] = c[u] +cost[u][v];//最短距离相同时，看c[v]能否更优\t\n\t\t}\n\t}\n}\n```\n\t②新增点权：给每个点增加一个点权（例如每个城市能收集到的物资），然后在最短路径\n\t有多条时要求路径上的点权之和最大（如果点权是其它含义也可以是最小）。\n```\n//w[]从起点s到顶点u能收集的最大物资w[u]\n//weight[u]表示城市u中的物资数目\n//初始化时只有w[s]为weight[u] 其余均为0\nfor(int v = 0; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tw[v] = w[u] + weight[v];\n\t\t}\n\t\telse if(d[u] + G[u][v] == d[v] && w[u] + weight[v] > w[v]){\n\t\t\t\t\tw[v] = w[u] + weight[v];\n\t\t}\n\t}\n}\n```\n\t③直接问有多少条最短路径\n```\n//num[]从起点s到达顶点u的最短路径条数为num[u]\n//初始化只有num[s] = 1 其余均为0\nfor(int v; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tnum[v] = num[u];\n\t\t}\n\t\telse if(d[u] + G[u][v] == d[v]){\n\t\t\tnum[v] += num[u];//最短距离相同时累加num\n\t\t}\n\t}\n}\n```\n## 全源最短路径\n### Floyd 算法\n```\n//Floyd算法\n枚举顶点 k ∈ [1,n]\n\t以顶点 k 作为中介点，枚举所有顶点对i和j （i，j∈ [1,n]）\n\t\t如果dis[i][k] + dis[k][j] < dis[i][j]成立\n\t\t\t赋值dis[i][j] = dis[i][k] + dis[k][j]\n```\n```\nint n, m; //n顶点数， m为边数\nint dis[MAXV][MAXV]; //dis[i][j]表示顶点i和j的最短距离\n\nvoid Floyd(){\n\tfor(int k = 0; k < n; k++) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(dis[i][k] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j])\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n# 最小生成树\n    如果是稠密图(边多) prim算法\n    如果是稀疏图(边少) kruskal算法\n## prim 算法\n```\nprim算法：对图G(V,E)设置集合S，存放已被访问的顶点，然后每次从集合V-S中选择\n与集合S的最短距离最小的一个顶点（记为u）访问并加入集合S。之后，令顶点u为中介点，\n优化所有从u能到达的顶点v与集合S之间的最短距离。这样执行操作n次（n为顶点个数），\n直到集合S已包含所有顶点。\nPrim(G, d[]){\n\t初始化\n\tfor(循环n次){\n\t\tu = 使d[u]最小的还未被访问的顶点的标号\n\t\tfor(从u除法能到达的所有顶点){\n\t\t\tif(v未被访问&& 以u为中介点使得v与集合S的最短距离d[v]更优){\n\t\t\t\t将G[u][v]赋值给v与集合S的最短距离d[v]\n\t\t\t}\n\t\t}\n\t}\n}\n```\n```\n//邻接矩阵\nint n, G[MAXV][MAXV]; //n为顶点数\nint d[MAXV]; //顶点与集合S的最短距离\nbool vis[MAXV] = {false}; //标记数组，vis[i] == true表示已访问。初值均为false\n\nint prim(){//默认0号为初始点\n\tfill(d, d + MAXV, INF);\n\td[0] = 0;\n\tint ans = 0; //存放最小生成树的边权之和\n\tfor(int i = 0; i < n; i++) {\n\t\tint u = -1, min = INF; //u使d[u]最小，min存放该最小的d[u]\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(vis[j] == false && d[j] < min) {\n\t\t\t\tu = j;\n\t\t\t\tmin = d[j];\n\t\t\t}\n\t\t}\n\t\t//找不到小于INF的d[u]，则剩下的顶点和集合S不连通\n\t\tif(u == -1) return -1;\n\t\tvis[u] = true;\n\t\tans += d[u];\n\t\tfor(int v = 0; v < n; v++) {\n\t\t\tif(G[u][v] != INF && vis[v] ==false && G[u][v] < d[v]){\n\t\t\t\td[v] = G[u][v];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n```\n```\n//邻接表\nstruct Node {\n\tint v, dis; //v为边的目标顶点，dis为边权\n};\n\nvector<Node> Adj[MAXV]\n\nfor(int j = 0; j < Adj[u].size(); j++) {\n\tint v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v\n\tif(vis[v] == false && Adj[u][j].dis < d[v]) {\n\t\td[v] = Adj[u][v].dis;\n\t} \n}\n```\n\n## kruskal 算法\n\n```\nkruskal算法采用\"边贪心\"策略，步骤：\n①对所有边按边权从小到大进行排序。\n②按边权从小到大测试所有边，如果当前测试所连接的两个顶点不在同一个连通块中，\n则把这条测试边加入当前最小生成树中；否则，将边舍弃\n③执行步骤②，直到最小生成树中的边数等于总顶点数-1或是测试完所有边时结束。\n而当结束时如果最小生成树的边数小于总顶点数-1，说明该图不连通\n\nstruct edge {\n\tint u, v;//边的两个端点编号\n\tint cost;//边权\n}E[MAXE];\n\nint kruskal(){\n\t令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;\n\t将所有边按边权从小到大排序;\n\tfor(从小到大枚举所有边){\n\t\tif(当前测试边的两个端点在不同的连通块中) {\n\t\t\t将该测试边加入最小生成树中;\n\t\t\tans += 测试边边权;\n\t\t\t最小生成树的当前边数Num_Edge 加 1;\n\t\t\t当边数Num_Edge等于顶点数减1时结束循环;\n\t\t}\n\t}\n\treturn ans;\n}\n```\n```\nint father[N];//并查集数组\nint findFather(int x){\n\tint a = x;\n\twhile(x != father[x])\n\t\tx = father[x];\n\twhile(a != father[a]){\n\t\tint z = a;\n\t\ta = father[a];//a进行回溯\n\t\tfather[z] = x;\n\t}\n\treturn x;\n}\n//n顶点数 m边数\nint kruskal(int n, int m){\n\tint ans = 0，Num_Edge = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tsort(E, E + m, cmp); //所有边按边权从小到大排序\n\tfor(int i = 0; i < m; i++) { //枚举所有边\n\t\tint faU = findFather(E[i].u);\n\t\tint faV = findFather(E[i].v);\n\t\tif(faU != faV) { //如果不在一个集合中\n\t\t\tfather[faU] = faV;\n\t\t\tans += E[i].cost;\n\t\t\tNum_Edge++;\n\t\t\tif(Num_Edge == n - 1) break;//边数等于顶点数减1时结束算法\n\t\t}\n\t}\n\tif(Num_Edge != n - 1) return -1; //无法连通时返回-1\n\telse return ans;\n}\n```","tags":["图论"],"categories":["algorithm"]},{"title":"debug","url":"/2019/10/24/warings/","content":"\ndebug 之于 coder\n\n<!-- more -->\n一定一定要会debug！debug！debug！血的教训，从来都不debug的我，上课看老师debuging都不以为意,大佬们给的建议也是左耳进右耳出。花了一下午和一个晚上的时间终于把b站图标给改出来了。以后工作了面对着几千行几万行代码你能一行一行查吗？  \n还有能用框架就用框架！那效率真的不是一般的高！别傻乎乎地一行一行地去敲。\n# 发此博客引以为戒！！！","tags":["警示"],"categories":["techs"]}]