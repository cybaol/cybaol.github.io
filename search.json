[{"title":"树算法","url":"/2020/03/13/Tree/","content":"早起的虫儿被鸟吃\n<!-- more -->\n\n\t* 二叉树的存储：链式存储和数组。\n\t* 二叉树的遍历：先序、中序、后序、层序。\n# 二叉树的遍历\n## 层序遍历\n```cpp\n//算法思想：\n//①将根节点root加入队列q。\n//②取出队首结点，访问之。\n//③如果该结点有左孩子，将左孩子入队。\n//④如果该结点有有孩子，将有孩子入队。\n//⑤返回②，直到队列为空。\n\nvoid LayerOrder(node* root) { //带层次\n\tqueue<node*> q;\n\troot->layer = 1;\n\tq.push(root);\n\twhile(!q.empty()){\n\t\tnode* p = q.front();\n\t\tq.pop();\n\t\tprintf(\"%d \", p->data);\n\t\tif(p->left != NULL) {\n\t\t\tp->left->layer = p->layer + 1;\n\t\t\tq.push(p->left);\n\t\t}\n\t\tif(p->right != NULL) {\n\t\t\tp->right->layer = p->layer + 1;\n\t\t\tq.push(p->right);\n\t\t}\n\t}\n}\n```\n\n# 建立二叉树\n## 已知先序中序\n```cpp\n//算法思想：\n//①先序数组的第零个结点为根结点。\n//②遍历中序数组找出根结点位置并记录。\n//③计算中序数组左子树个数\n//④递归建立左右子树。\n\n//其他情况算法类似，重点是确定根结点和数组区间范围。\n\nnode* create(int preL, int preR, int inL, int inR) {\n\tif(preL > preR) return NULL;\n\tnode* root = new node;\n\troot->data = pre[preL];\n\tint k = inL;\n\tfor(; k < inR; k++)\n\t\tif(in[k] == root->data) break;\n\tint numLeft = k - inL;\n\troot->left = create(preL + 1, preL + numLeft, inL, k - 1);\n\troot->right = create(preL + numLeft + 1, preR, k + 1, inR);\n\treturn root;\n}\n```\n\n# 二叉查找树(BST)\n\t* 左边小右边大\n\t* 对二叉查找树进行\"中序\"遍历，遍历结果是有序的\n\t* 如果给定序列是有序的或者排序后有序，可以中序递归建立BST\n## 查找操作\n```cpp\nvoid search(node* root, const int x) {\n\tif(root == NULL) {\n\t\tprintf(\"search failed!\\n\");\n\t\treturn;\n\t}\n\tif(x == root->data)\n\t\tprintf(\"%d\\n\", root->data);\n\telse if(x < root->data)\n\t\tsearch(root->left, x);\n\telse\n\t\tsearch(root->right, x);\n}\n```\n## 插入操作\n```cpp\nvoid insert(node* &root, const int x) {\n\tif(root == NULL) { //插入位置\n\t\troot = new node;\n\t\troot->data = x;\n\t\troot->left = root->right = NULL;\n\t\treturn;\n\t}\n\tif(x == root->data) return; //结点已存在 直接返回\n\telse if(x < root->data)\n\t\tinsert(root->left, x);\n\telse\n\t\tinsert(root->right, x);\n}\n```\n## 二叉查找树的建立\n```cpp\nnode* create(int data[]) {\n\tnode* root = NULL;\n\tfor(const auto val : data) insert(root, val);\n\treturn root;\n}\n```\n## 二叉查找树的删除\n```cpp\n//寻找以root为根结点的树中的最大权值结点\nnode* findMAX(node* root) {\n\twhile(root->right != NULL)\n\t\troot = root->right;\n\treturn root;\n}\n//寻找以root为根结点的树中的最小权值结点\nnode* findMin(node* root) {\n\twhile(root->left != NULL)\n\t\troot = root->left;\n\treturn root;\n}\n```\n```cpp\n//算法思想：\n//①如果当前结点root为空，说明不存在权值为给定权值 直接返回。\n//②如果当前结点root的权值恰为给定权值x，进入删除处理\n//a)如果当前结点root不存在左右孩子，说明叶子结点，直接删除。\n//b)如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然//后让pre的数据覆盖root，接着在左子树中删除结点pre。\n//c)如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，//然后让next的数据覆盖root，接着在右子树中删除结点next。\n//③如果给定的权值x小于当前结点的权值，则在左子树中递归删除权值为x//的结点。\n//④如果给定的权值x大于当前结点的权值，则在右子树中递归删除权值为x//的结点。\n\nvoid deleteNode(node* root, int x) {\n\tif(root == NULL) return; //不存在权值为x的结点\n\tif(x == root->data) {//找到欲删除结点\n\t\t//delete(root);\n\t\tif(root->left == NULL && root->right == NULL)\n\t\t\troot = NULL;\n\t\telse if(root->left != NULL) {\n\t\t\tnode* pre = findMAX(root->left, x);\n\t\t\troot->data = pre->data;\n\t\t\tdeleteNode(root->left, pre->data);\n\t\t}\n\t\telse {\n\t\t\tnode* next = findMin(root->right);\n\t\t\troot->data = next->data;\n\t\t\tdeleteNode(root->right, next->data);\n\t\t}\n\t}\n\telse if(x < root->data)\n\t\tdeleteNode(root->left, x);\n\telse\n\t\tdeleteNode(root->right, x);\n}\n```\n# 平衡二叉树(AVL树)\n\t* AVL树是一棵二叉查找树\n\t* 任意结点的左右子树高度之差(平衡因子)的绝对值不超过1\n```cpp\nstruct node {\n\tint v, height;\n\tnode *left, *right;\n};\n\nint getHeight(node* root) {\n\tif(root == NULL) return 0;\n\telse return root->height;\n}\n\nint getBalanceFactor(node* root) {\n\treturn getHeight(root->left) - getHeight(root->right);\n}\n\nvoid updateHeight(node* root) {\n\troot->height = max(getHeight(root->left), getHeight(root->right)) + 1;\n}\n```\n## 查找操作\n```cpp\nvoid search(node* root, const int x) {\n\tif(root == NULL) {\n\t\tprintf(\"search failed!\\n\");\n\t\treturn;\n\t}\n\tif(x == root->data)\n\t\tprintf(\"%d\\n\", root->data);\n\telse if(x < root->data)\n\t\tsearch(root->left, x);\n\telse\n\t\tsearch(root->right, x);\n}\n```\n## 插入操作\n```cpp\n//旋转问题：\n//左旋(Left Rotation)算法思想：\n//①让B的左子树◆成为A的右子树\n//②让A成为B的左子树\n//③将根结点设定为结点B\n\nvoid L(node* &root) {\n\tnode* p = root->right;\n\troot->right = p->left;\n\tp->left = root;\n\tupdateHeight(root);\n\tupdateHeight(p);\n\troot = p;\n}\n\n//右旋(Right Rotation)算法思想：\n//①让A的右子树◆成为B的左子树\n//②让B成为A的右子树\n//③将根结点设定为结点A\n\nvoid R(node* &root) {\n\tnode* p = root->left;\n\troot->left = p->right;\n\tp->right = root;\n\tupdateHeight(root);\n\tupdateHeight(p);\n\troot = p;\n}\n```\n```cpp\n//只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会正常(可证明)\n//分LL型、LR型、RR型、RL型\n//LR -> LL | RL -> RR\nvoid insert(node* &root, const int v) {\n\tif(root == NULL) { //插入位置\n\t\troot = new node;\n\t\troot->v = v;\n\t\troot->height = 1;\n\t\troot->left = root->right = NULL;\n\t\treturn;\n\t}\n\tif(v < root->v) {\n\t\tinsert(root->left, v);\n\t\tupdateHeight(root);\n\t\tif(getBalanceFactor(root) == 2) {\n\t\t\tif(getBalanceFactor(root->left) == 1) //LL型\n\t\t\t\tR(root);\n\t\t\telse if(getBalanceFactor(root->left) == -1) { //LR型\n\t\t\t\tL(root->left);\n\t\t\t\tR(root);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tinsert(root->right, v);\n\t\tupdateHeight(root);\n\t\tif(getBalanceFactor(root) == -2) {\n\t\t\tif(getBalanceFactor(root->right) == -1) //RR型\n\t\t\t\tL(root);\n\t\t\telse if(getBalanceFactor(root->left) == 1) { //RL型\n\t\t\t\tR(root->right);\n\t\t\t\tL(root);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## AVL树的建立\n```cpp\nnode* create(int data[]) {\n\tnode* root = NULL;\n\tfor(const auto v : data) insert(root, v);\n\treturn root;\n}\n```\n\n# 并查集\n\t* 合并：合并两个集合\n\t* 查找：判断两个元素是否在一个集合\n\t* 并查集产生的每一个集合都是一棵树\n\t* int father[N]; //并查集数组\n## 初始化\n```cpp\nfor(int i = 1; i <= N; i++)\n\tfather[i] = i;\n```\n## 查找\n```cpp\n//iterator\nint findFather(int x){\n\twhile(x != father[x]) x = father[x];\n\treturn x;\n}\n//recursion\nint findFather(int x) {\n\tif(x == father[x]) return x;\n\telse return findFather(father[x]);\n}\n```\n## 合并\n```cpp\nvoid Union(int a, int b) {\n\tint faA = findFather(a);\n\tint faB = findFather(b);\n\tif(faA != faB)\n\t\tfather[faA] = faB;\n}\n```\n## 路径压缩\n```cpp\n//算法思想：\n//①按原来的写法获得v的根结点root\n//②重新从v开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲//全部改为根结点\nint findFather(int v) { //T(n) = O(1)\n\tif(v == father[v]) return v; // 找到根结点\n\telse {\n\t\t//让当前结点v的父亲全部改为根结点\n\t\tint root = findFather(father[v]);\n\t\tfather[v] = root;\n\t\treturn root;\n\t}\n}\n```\n# 堆与堆排序\n\t* 堆是一个完全二叉树\n\t* 大顶堆 和 小顶堆\n\t* 堆可以用来实现优先队列\n\t* int heap[maxn], n; // n为元素个数\n## 向下调整\n```cpp\n//向下调整 T(n) = O(logn)\n//其中low为欲调整的数组下表，high一般为堆的最后一个元素的数组下标\nvoid downAdjust(int low, int high) {\n\tint i = low, j = i * 2;\n\twhile(j <= high) {\n\t\tif(j + 1 <= high && heap[j+1] > heap[j])\n\t\t\tj = j + 1;\n\t\tif(heap[j] > heap[i]) {\n\t\t\tswap(heap[j], heap[i]);\n\t\t\ti = j;\n\t\t\tj = i * 2;\n\t\t}\n\t\telse break;\n\t}\n}\n```\n## 建堆\n```cpp\n//从最后一名同学位置开始，从下往上 从右往左\n//左轮·D·普拉西多\n// T(n) = O(n)\nvoid createHeap() {\n\tfor (int i = n / 2; i >= 1; i--) {\n\t\tdownAdjust(i, n);\n\t}\n}\n```\n## 删除堆顶\n```cpp\n// T(n) = O(n)\nvoid deleteTop(){\n\theap[1] = heap[n--]; //用最后一个元素覆盖堆顶元素，并让元素个数减1\n\tdownAdjust(1,n);\n}\n```\n## 向上调整\n```cpp\n// T(n) = O(logn)\nvoid upAdjust(int low, int high) {\n\tint i = high, j = i / 2;\n\twhile(j >= low){\n\t\tif(heap[i] > heap[j]){\n\t\t\tswap(heap[i], heap[j]);\n\t\t\ti = j;\n\t\t\tj = i / 2;\n\t\t}\n\t\telse break;\n\t}\n}\n```\n\n## 堆的插入\n```cpp\nvoid insert(node* root, int x) {\n\theap[++n] = x; // 加入到堆最后一个元素后面，并让元素个数加1\n\tupAdjust(1, n);\n}\n```\n## 堆排序(heap sort)\n```cpp\nvoid heapSort() {\n\tcreateHeap();\n\tfor (int i = n; i > 1; i--){\n\t\tswap(heap[1], heap[i]);\n\t\tdownAdjust(1,i - 1);\n\t}\n}\n```\n# 哈夫曼树\n```cpp\n//算法思想：\n//反复选择两个最小的元素，合并，直到只剩下一个元素\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\npriority_queue<long long, vector<long long>, greater<long long> > q;\n\nint main() {\n\tint n;\n\tlong long temp, x, y, ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld\", &temp);\n\t\tq.push(temp);\n\t}\n\twhile(q.size() > 1) {\n\t\tx = q.top();\n\t\tq.pop();\n\t\ty = q.top();\n\t\tq.pop();\n\t\tq.push(x + y);\n\t\tans += x + y;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n```","tags":["树"],"categories":["algorithm"]},{"title":"Be a magical developer","url":"/2019/11/19/ambition/","content":"《一百种自杀方法》最后一页写着活下去。\n<!-- more -->\n\n* [费曼学习法](https://www.choupangxia.com/2019/09/26/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/)  \n* 康奈尔笔记  \n* 数据结构与算法(不C9 无算法 一直都坚信它是程序的灵魂 加油)([PKU](https://www.bilibili.com/video/av7134874)+[THU](https://www.bilibili.com/video/av49361421)+[MIT](https://www.bilibili.com/video/av48922404?p=21)+算法导论英文第三版) \n* 计算机组成原理(秃头程序员的进阶感觉可还行)([HIT](https://www.bilibili.com/video/av15123338))   \n* 操作系统(听说过bug10吧) ([PKU](https://www.bilibili.com/video/av6538245))  \n* 计算机网络(学好卖网线)(自顶而下英文原版)\n* 编译原理([HIT](https://www.bilibili.com/video/av17649289))\n* 嵌入式系统([学堂在线](https://next.xuetangx.com/))\n* 信息论与编码（[THU](https://www.bilibili.com/video/av28661250)+[西电](https://www.bilibili.com/video/av26735580)）\n* [ML](https://www.bilibili.com/video/av9912938)  \n* 前端  \n* 数据库  \n* 健身  \n* 个人札记  \n    1. 学点经济学\n\t2. 为竞赛而生  \n\t3. 多看英文原版书  \n\t4. 多线程+设计模式  \n\t5. 多看项目源码  \n\t6. 脚踏实地的理想主义者，既要有高远的理想也要有脚踏实地的精神  \n\t7. 他们只是起点比我们高 -- 2018-10-3 打卡南京大学鼓楼校区  \n\t8. 见见有趣的人，读读有趣的书，讲讲有趣的故事。  \n\t9. 有时候我们会觉得自己后知后觉，那是因为学习的太少，了解的太少，很多问题前人已经总结好了现成的方法和方案，我们却不知道，还在自己探索，当然行动缓慢，后知后觉了。只有站在巨人的肩膀上才能看得更远。   \n\t10. 2019-10-26打卡东南大学四牌楼校区图书馆   \n\t11. [C语言笔记](https://app.yinxiang.com/shard/s40/nl/24222849/82d590e6-3c3b-4af1-87c2-8964f41501e9/)  \n","tags":["成长"],"categories":["techs"]},{"title":"大学阅读记录","url":"/2019/11/07/book/","content":"\n![一起努力(劝退)](./20191120135008.jpg)\n\n<!-- more -->\n\n## 算法类\n花费我时间最长的东西 不放在第一位都觉得对不起自己.  \n* Introduction to Algorithms  \n* 大话数据结构  \n* 算法笔记  \n* 算法笔记上机训练实战指南  \n* 数学之美\n* 算法之美  \n* 初等数论  \n* 啊哈算法   \n* 算法竞赛入门经典（第2版）  \n* 算法竞赛入门经典训练指南  \n* 大学生程序设计课程与竞赛训练教材-算法设计编程实验 \n## 语言类杂书\n同类书籍看了一堆又一堆 就觉得这几本有点意思(索然无味).  \n* C Traps and Pitfalls  \n* Expert C Programming  \n* C Pointer  \n* C++ STL  \n* C++ 11  \n* Thinking in C++  \n* Effective C++  \n* More Effective C++  \n* Inside The C++ Object Model  \n* The C++ Standard Library  \n* Computer Network A Top-Down Approach  \n## Python小爬虫\n骚不动系列，只看了一本两个晚上93分过期末。。。  \n* Python编程: 从入门到实践  \n## 硬件之路\n* Computer System A Programmer's Perspective  \n* Computer Organization And Design the hardware/software interface  \n* Computer Architecture A Quantitative Approach  \n* ARM Cortex-M0 and Cortex-M0+ Processors  \n* See MIPS Run","tags":["阅读"],"categories":["books"]},{"title":"图论算法","url":"/2019/11/01/Graph/","content":"\n早起的鸟儿有虫吃\n\n<!-- more -->\n# 图的遍历\n    * 有两种存储方式：邻接矩阵和邻接表\n    * 在一些顶点数目比较大（一般顶点个数在1000以上）的情况下，使用邻接表而  \n    不是邻接矩阵来存储图。如果是稀疏图，用邻接表，如果是稠密图，用邻接矩阵。\n\n## 深度优先搜索dfs遍历图\n```cpp\n//按深度优先的方式访问所有未被访问的结点，在结点被访问过后标记为已访问\ndfs(u) {\n  vis[u] = true;\n  for(从u出发到能到达的所有顶点v)\n    if(vis[v] == false)\n      dfs(v);\n}\ndfsTravel(G) {\n  for(G的所有顶点u)\n    if(vis[u] == false)\n      dfs(u); //访问u所在连通块\n}\n```\n\n```cpp  \n//邻接矩阵版 DFS\n\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool vis[maxV] = {false};//记录顶点是否被访问过\n\nvoid dfs(int u, int depth) {\n    vis[u] = true;\n    for(int v = 0; v < n; v++)//遍历u可以到达的顶点v\n        if(G[u][v] != INF && vis[v] == false)\n            dfs(v, depth + 1);//访问v 深度+1\n}\n\nvoid travelDFS() {\n    for(int u = 0; u < n; u++)\n        if(vis[u] == false)\n            dfs(u, 1);//访问u和u所在的连通块\n}```\n```cpp\n//邻接表版 DFS\n\nvector<int> arr[maxn];\n\nvoid dfs(int u, int depth) {\n  vis[u] = true;\n  for(int i = 0; i < arr[u].size(); i++){\n\tint v = arr[u][i];\n\tif(vis[i] == false)\n    \tdfs(v, depth + 1);\n  }\n}\n\nvoid dfsTrave() {\n  for(int u = 0; u < n; u++) {\n    if(vis[u] == false)\n      dfs(u, 1);\n  }\n}\n```\n## 广度优先搜索bfs遍历图\n```cpp\n//建立一个队列，把初始定点加入队列，然后每次都取出队首元素进行访问，并把该定点  \n//除法可以到达的未曾加入过队列（而不是未访问）的顶点全部加入队列，直到队列为空。\nbfs(u) {\n  queue q;\n  将u入队\n  inq[u] = true;\n  while(q非空) {\n    for(从u出发到可到达的所有顶点v) {\n      if(inq[v] == false)\n        将v入队\n        inq[v] = true;\n    }\n  }\n}\n\nbfsTrave(G) {\n  for(G的所有顶点u) {\n    if(inq[u] == false)\n      bfs(u);\n  }\n}\n```\n\n```cpp\n//邻接矩阵版 BFS\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool inq[maxV] = {false};//记录顶点的是否入队\n\nvoid bfs(int u) {//u顶点编号\n\tqueue<int> q;\n\tq.push(u);//入队\n\tinq[u] = true;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int v = 0; v < n; v++)//遍历u所在连通块（未入队）并入队\n\t\t\tif(G[u][v] != INF && inq[v] == false){\n\t\t\t\tq.push(v);、\n\t\t\t\tinq[v] = true;\n\t\t\t}\n\t}\n}\n\n/*邻接表：\nfor(int i = 0; i < arr[u].size(); i++) {\n  int v= arr[u][i];\n  if(inq[v] == false) {\n    q.push(v);\n    inq[v] = true;\n  }\n}\n*/\n\nvoid travelBFS() {\n\tfor(int v = 0; v < n; v++)\n\t\tif (inq[v] == false)\n\t\t\tbfs(v);//遍历v及其所在连通块\n}```\n\n```cpp\n//带层数的 邻接表\nstruct node {\n  int v;//顶点编号\n  int layer;//顶点层号\n};\nnext.layer = curNode.layer + 1;\n//邻接表中的类型是node，而不是int\nvector<node> Adj[N];\n```\n# 最短路径\n\t* 单源最短路径：计算源点到其他各顶点的最短路径的长度\n\t* 全局最短路径：图中任意两点的最短路径\n\t* Dijkstra、Bellman-Ford、SPFA求单源最短路径\n\t* Floyd-Warshall可以求全局最短路径，但是效率比较低\n\t* SPFA算法是Bellman-Ford算法的队列优化\n\t* Dijkstra算法不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径\n\t* Bellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行\n\t* 深度优先遍历可以求一个点到另一个点的最短路径的长度\n## 单源最短路径\n\t思想来源：图的广度优先遍历bfs\n### Dijkstra 算法\n```cpp\n//Dijkstra 算法：\n//对图G(V,E)设置集合S，存放已被访问的顶点，\n//然后每次从集合V-S中选择与起点s的最短距离最小的一个顶点(记为u),访问并加入集合S，\n//之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v的最短距离，\n//这样的操作执行n次,直到集合S已包含所有顶点。\n\nint G[maxSize][maxSize], n;\nint d[maxSize];\nint pre[maxSize];\nbool vis[maxSize] = {false};\n//邻接矩阵\nvoid Dijkstra(int s) { //T(n) = O(V^2)\n\tfill(d, d + maxSize, INF);\n\td[s] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tint u = -1, min = INF;//u 保存最短路径顶点，min保存最短距离\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif(vis[j] == false && d[j] < min) {\n\t\t\t\tu = j;\n\t\t\t\tmin = d[j];\n\t\t\t}\n\t\t//找不到小于INF的d[u]，说明剩下的顶点与起点s不连通\n\t\tif(u == -1) return;\n\t\tvis[u] = true;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\t//以u为中介点使可以使d[v]更优\n\t\t\tif(G[u][v] != INF && vis[v] == false && d[u] + G[u][v] < d[v]) {\n\t\t\t\td[v] = d[u] + G[u][v];\n\t\t\t\tpre[v] = u; //记录v的前驱结点u\n\t\t\t}\n\t\t}\n\t}\n}\n```\n```cpp\n//邻接表\nstruct Node {\n\tint v, dis; //v为边的目标顶点，dis为边权\n};\n\nvector<Node> Adj[MAXV];\n\nfor(int j = 0; j < Adj[u].size(); j++) {\n\tint v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v\n\tif(vis[v] == false && d[u] + Adj[u][v].dis < d[v]) {\n\t\td[v] = d[u] + Adj[u][v].dis;\n\t} \n}\n\n\n```\n\n```cpp\n//无向图解决方案: 把无向边当成指向相反的有向边\n\nvoid DFS(int s, int v) {//s起点编号，v是当前访问的顶点编号（从终点开始递归）\n\tif(v == s) { //如果当前已经打扫起点s，则输出起点并返回\n\t\tprintf(\"%d\\n\", s);\n\t\treturn;\n\t}\n\tDFS(s, pre[v]); //递归访问v的前驱结点pre[v]\n\tprintf(\"%d\\n\", v);//从最深处return回来之后，输出每一层的顶点号\n}\n```\n\t附加考法：第一标尺是距离，第二标尺常见有三种\n\t①新增边权：给每条边再增加一个边权（比如花费），然后要求在最短路径有多条时要求路径上的花费之和最小（如果边权是其它含义，也可以是最大）。\n```cpp\n//c[] 从起点s到达顶点u的最少花费c[u]\n//cost[u][v]表示u->v的花费\n//初始化时只有c[s] = 0 其余均为INF\nfor(int v = 0; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tc[v] = c[u] +cost[u][v];\n\t\t}\n\t\telse if(d[u] + G[u][v] == d[v] && c[u] +cost[u][v] < c[v]){\n\t\t\tc[v] = c[u] +cost[u][v];//最短距离相同时，看c[v]能否更优\t\n\t\t}\n\t}\n}\n```\n\t②新增点权：给每个点增加一个点权（例如每个城市能收集到的物资），然后在最短路径\n\t有多条时要求路径上的点权之和最大（如果点权是其它含义也可以是最小）。\n```cpp\n//w[]从起点s到顶点u能收集的最大物资w[u]\n//weight[u]表示城市u中的物资数目\n//初始化时只有w[s]为weight[s] 其余均为0\nfor(int v = 0; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tw[v] = w[u] + weight[v];\n\t\t}\n\t\telse if(d[u] + G[u][v] == d[v] && w[u] + weight[v] > w[v]){\n\t\t\tw[v] = w[u] + weight[v];\n\t\t}\n\t}\n}\n```\n\t③直接问有多少条最短路径\n```cpp\n//num[]从起点s到达顶点u的最短路径条数为num[u]\n//初始化只有num[s] = 1 其余均为0\nfor(int v = 0; v < n; v++) {\n\tif(G[u][v] != INF && vis[v] == false) {\n\t\tif(d[u] + G[u][v] < d[v]) {\n\t\t\td[v] = d[u] + G[u][v];\n\t\t\tnum[v] = num[u];\n\t\t}\n\t\telse if(d[u] + G[u][v] == d[v]){\n\t\t\tnum[v] += num[u];//最短距离相同时累加num\n\t\t}\n\t}\n}\n```\n### Bellman-Ford 算法\n```cpp\n// 零环、正环、负环\n//零环和正环不会影响最短路径求解（因为不能使最短路径更短）\n//负环 从源点可以到达，会影响最短路径求解（无法从源点除法到达 不会影响）\n//算法思想：\n//需要对图中的边进行V - 1轮操作，每轮都遍历图中的所有边：对每条边u->v, \n//如果以u为中介点可以使d[v]更小，即d[u] + length[u->v] < d[v]成立时，\n//就用d[u] + length[u->v] 更新d[v]。\n//T(n) = O(VE)\n//第k轮得到从0号顶点\"最多通过k条边到达其余各顶点的最短路径长度\"\nstruct Node {\n\tint v, dis; //v为邻接边的目标顶点, dis为邻接边的边权\n};\nvector<Node> Adj[MAXV]; //邻接表\nint n, d[MAXV]; //n顶点数，d[]用来存放从源点s到达各个顶点的最短距离\n\nbool Bellman(int s) {\n\tfill(s, d + MAXV, INF);\n\td[s] = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tfor(u = 0; u < n; u++){//遍历所有边\n\t\t\tfor(int j = 0; j < Adj[u].size(); j++) {\n\t\t\t\tint v = Adj[u][j].v;\n\t\t\t\tint dis = Adj[u][j].dis;\n\t\t\t\tif(d[u] + dis < d[v]) {\n\t\t\t\t\td[v] = d[u] + dis; //松弛操作\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//判断负环代码\n\tfor(int u = 0; u < n; u++) {\n\t\tfor(int j = 0; j < Adj[u].size(); j++) {\n\t\t\tint v = Adj[u][j].v;\n\t\t\tint dis = Adj[u][j].dis;\n\t\t\tif(d[u] + dis < d[v]) {\n\t\t\t\treturn false; //说明图中有从源点可达的负环\n\t\t\t}\n\t\t}\n\t}\n\treturn true; //数组d的所有值都已经达到最优\n}\n\n```\n### SPFA 算法\n```cpp\n//Shortest Path Faster Algorithm\n//T(n) = O(kE) , k <= 2\n//理解SPFA的关键是理解它是如何从Bellman-Ford算法优化得来的\nqueue<int> q;\n源点s入队\nwhile(队列非空) {\n\t取出队首元素\n\tfor(u的所有邻接边u->v) {\n\t\tif(d[u] + dis < d[v]) {\n\t\t\td[v] = d[u] + dis;\n\t\t\tif(v当前不在队列) {\n\t\t\t\tv入队;\n\t\t\t\tif(v入队次数大于n - 1) {\n\t\t\t\t\t说明有可达负环，return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## 全源最短路径\n### Floyd 算法\n```cpp\n//Floyd算法\n枚举顶点 k ∈ [1,n]\n\t以顶点 k 作为中介点，枚举所有顶点对i和j （i，j∈ [1,n]）\n\t\t如果dis[i][k] + dis[k][j] < dis[i][j]成立\n\t\t\t赋值dis[i][j] = dis[i][k] + dis[k][j]\n```\n```cpp\nint n, m; //n顶点数， m为边数\nint dis[MAXV][MAXV]; //dis[i][j]表示顶点i和j的最短距离\n\nvoid Floyd(){\n\tfor(int k = 0; k < n; k++) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(dis[i][k] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j])\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n# 最小生成树\n    * 如果是稠密图(边多) prim算法\n    * 如果是稀疏图(边少) kruskal算法\n## prim 算法\n```cpp\n//prim算法：\n//对图G(V,E)设置集合S，存放已被访问的顶点，\n//然后每次从集合V-S中选择与集合S的最短距离最小的一个顶点（记为u）访问并加入集合S。\n//之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。\n//这样执行操作n次（n为顶点个数），直到集合S已包含所有顶点。\n//prim算法和Dijkstra算法只有优化d[v]部分不同\n//prim算法和Dijkstra算法思路完全相同，只不过是数组d[]含义不同\nPrim(G, d[]){\n\t初始化\n\tfor(循环n次){\n\t\tu = 使d[u]最小的还未被访问的顶点的标号\n\t\tfor(从u除法能到达的所有顶点){\n\t\t\tif(v未被访问&& 以u为中介点使得v与集合S的最短距离d[v]更优){\n\t\t\t\t将G[u][v]赋值给v与集合S的最短距离d[v]\n\t\t\t}\n\t\t}\n\t}\n}\n```\n```cpp\n//邻接矩阵\nint n, G[MAXV][MAXV]; //n为顶点数\nint d[MAXV]; //顶点与集合S的最短距离\nbool vis[MAXV] = {false}; //标记数组，vis[i] == true表示已访问。初值均为false\n\nint prim(){//默认0号为初始点\n\tfill(d, d + MAXV, INF);\n\td[0] = 0;\n\tint ans = 0; //存放最小生成树的边权之和\n\tfor(int i = 0; i < n; i++) {\n\t\tint u = -1, min = INF; //u使d[u]最小，min存放该最小的d[u]\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(vis[j] == false && d[j] < min) {\n\t\t\t\tu = j;\n\t\t\t\tmin = d[j];\n\t\t\t}\n\t\t}\n\t\t//找不到小于INF的d[u]，则剩下的顶点和集合S不连通\n\t\tif(u == -1) return -1;\n\t\tvis[u] = true;\n\t\tans += d[u];\n\t\tfor(int v = 0; v < n; v++) {\n\t\t\tif(G[u][v] != INF && vis[v] ==false && G[u][v] < d[v]){\n\t\t\t\td[v] = G[u][v];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n```\n```cpp\n//邻接表\nstruct Node {\n\tint v, dis; //v为边的目标顶点，dis为边权\n};\n\nvector<Node> Adj[MAXV]\n\nfor(int j = 0; j < Adj[u].size(); j++) {\n\tint v = Adj[u][j].v; //通过邻接表直接获得u能到达的顶点v\n\tif(vis[v] == false && Adj[u][j].dis < d[v]) {\n\t\td[v] = Adj[u][v].dis;\n\t} \n}\n```\n\n## kruskal 算法\n\n```cpp\n//kruskal算法采用\"边贪心\"策略，步骤：\n//①对所有边按边权从小到大进行排序。\n//②按边权从小到大测试所有边，如果当前测试所连接的两个顶点不在同一//个连通块中，\n//则把这条测试边加入当前最小生成树中；否则，将边舍弃\n//③执行步骤②，直到最小生成树中的边数等于总顶点数-1或是测试完所有边//时结束。\n//而当结束时如果最小生成树的边数小于总顶点数-1，说明该图不连通\n\nstruct edge {\n\tint u, v;//边的两个端点编号\n\tint cost;//边权\n}E[MAXE];\n\nint kruskal(){\n\t令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;\n\t将所有边按边权从小到大排序;\n\tfor(从小到大枚举所有边){\n\t\tif(当前测试边的两个端点在不同的连通块中) {\n\t\t\t将该测试边加入最小生成树中;\n\t\t\tans += 测试边边权;\n\t\t\t最小生成树的当前边数Num_Edge 加 1;\n\t\t\t当边数Num_Edge等于顶点数减1时结束循环;\n\t\t}\n\t}\n\treturn ans;\n}\n```\n```cpp\nint father[N];//并查集数组\nint findFather(int x){\n\twhile(x != father[x]) x = father[x];\n\treturn x;\n}\n\nbool cmp(edge a, edge b) {\n\treturn a.cost < b.cost;\n}\n\nint kruskal(int n, int m){ //n顶点数 m边数\n\tint ans = 0，Num_Edge = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfather[i] = i;\n\t}\n\tsort(E, E + m, cmp); //所有边按边权从小到大排序\n\tfor(int i = 0; i < m; i++) { //枚举所有边\n\t\tint faU = findFather(E[i].u);\n\t\tint faV = findFather(E[i].v);\n\t\tif(faU != faV) { //如果不在一个集合中\n\t\t\tfather[faU] = faV;\n\t\t\tans += E[i].cost;\n\t\t\tNum_Edge++;\n\t\t\tif(Num_Edge == n - 1) break;//边数等于顶点数减1时结束算法\n\t\t}\n\t}\n\tif(Num_Edge != n - 1) return -1; //无法连通时返回-1\n\telse return ans;\n}\n```\n# 拓扑排序\n```cpp\n//算法思想：\n//①定义一个队列Q,并把所有入度为0的结点加入队列\n//②当队列不空时，取队首结点，输出然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，\n//如果某个顶点的入度减为0，则将其加入队列\n//③反复进行②操作，直到队列为空。\n//如果队列为空时入过队的结点数目恰好为N，说明拓扑排序成功，图G为有向无环图；否则，拓扑排序失败，图G中有环\n\n//拓扑排序可以判断一个给定的图是否是\"有向无环图\"\n//如果有多个入度为0的顶点，选择编号最小的顶点，那么把queue改成priority_queue，\n//并保持堆顶元素是优先队列中的最小元素即可。(set也行)\n\nvector<int> G[MAXV]; //邻接表\nint n, inDegree[MAXV];\nbool topologicalSort() {\n\tqueue<int> q;\n\tint num = 0; //记录加入拓扑排序的顶点数\n\tfor(int i = 0; i < n; i++) {\n\t\tif(inDegree[i] == 0) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\t//printf(\"%d \", u); //此处可输出顶点u，作为拓扑序列中的顶点\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i]; //u的后继v\n\t\t\tinDegree[v]--;\n\t\t\tif(inDegree[v] == 0) {\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tG[u].clear(); //清空顶点u的所有出边（可写可不写）\n\t\tnum++; //加入拓扑排序的顶点数加1\n\t}\n\tif(num == n) return true;\n\telse return false;\n}\n```\n# 关键路径\n## AOV网 和 AOE网\n```cpp\n//AOV: Activity On Vertex\n//AOE: Activity On Edge\n//AOV, AOE不应当有环\n/*\n *AOV网只有一个源点(入度为0)和一个汇点(出度为0)，若有多个源点和多*个汇点，也可转化为一个源点和一个汇点的情况\n *即添加一个\"超级源点\"和一个\"超级汇点\"，\n *方法：从超级源点出发，连接所有入度为0的点；从所有出度为0的点出**发，连接超级汇点；添加的有向边的边权均为0\n */\n/*\n *如果给定AOV网中各顶点所需要的时间，那么可以将AOV网转化成AOE网\n *方法：将AOV网中每个顶点都拆成两个顶点。分别表示活动的起点和终点，\n *而两个顶点之间用有向边连接，该有向边表示原顶点的活动，边权给定；\n *原AOV网中的边全部视为空活动，边权为0\n */\n/*\n *AOE网需要着重解决两个问题：\n *a. 工程起始到终止至少需要多少时间；\n *b. 那条(些)路径上的活动是影响整个工程进度的关键\n */\n//AOE网中的\"最长路径\"称为\"关键路径\"，关键路径上的活动称为关键活动\n```\n## 最长路径算法\n```cpp\n//算法思想：\n//把所有边的边权乘以-1，然后使用 Bellman-Ford算法 或 SPFA算法 求最长路径长度，将所得结果取反。\n//注意：此处不能用Dijkstra算法，原因是Dijkstra算法不能处理负权边的情况。\n\n//最长路径问题，即 Longest Path Problem，寻求的是图中的\"最长简单路径\"\n//如果图中有正环，则最长路径不存在。但最长简单路径存在，但你用Bellman-Ford算法求不出来(你说气不气)\n//但我后面有简单方法鸭(*^▽^*)  (〃'▽'〃)哪呢\n```\n## 关键路径算法\n```cpp\nstruct node {\n\tint v, w;\n};\nvector<node> G[MAXV]; //邻接表\n\n//先求点，再夹边\n//ve[] 事件最早发生时间 //取最大\nstack<int> topOrder; //留着求vl[], 不然我吃饱了撑的没事干急的啊\nbool topologicalSort() {\n\tqueue<int> q;\n\tfor(int i= 0; i < n; i++) {\n\t\tif(inDegree[i] == 0) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\ttopOrder.push(u);\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i].v; //u的i号后继结点编号为v\n\t\t\tinDegree[v]--;\n\t\t\tif(inDegree[v] == 0) {\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\tif(ve[u] + G[u][v].w > ve[v]) {\n\t\t\t\t//用ve[u]来更新u的所有后继结点v\n\t\t\t\tve[v] = ve[u] + G[u][v].w;\n\t\t\t}\n\t\t}\n\t}\n\tif(topOrder.size() == n) return true;\n\telse return false;\n}\n\n//vl[] 事件最晚发生时间 //取最小\nfill(vl,vl + n, ve[n - 1]); //vl数组初始化，初始值为终点的ve值\nwhile(!topOrder.empty()) {\n\tint u = topOrder.top();\n\ttopOrder.pop();\n\tfor(int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i].v;\n\t\tif(vl[v] - G[u][i].w < vl[u]) {\n\t\t\t//用u的所有后继结点v的vl值来更新vl[u]\n\t\t\tvl[u] = vl[v] - G[u][i].w;\n\t\t}\n\t}\n}\n```\n```cpp\n//下面代码中未保存活动的最早开始时间e和最迟开始时间l\n//原因是e 和 l只用来判断当前活动是否为关键路径\n//如果需要保存则在结构体node中添加域e 和 l\nint criticalPath() {\n\tmenset(ve, 0, sizeof(ve)); //ve[]初始化\n\tif(topologicalSort() == false) {\n\t\treturn -1; //不是有向无环图 返回-1\n\t}\n\n\t/*\n\t如果事先不知道汇点编号，可以取ve[]的最大值来得到关键路径长度\n\tint maxLength = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(maxLength < ve[i]) {\n\t\t\tmaxLength = ve[i];\n\t\t}\n\t}\n\tfill(vl, vl + n, maxLength);\n\t别忘了替换函数返回值\n\t*/\n\n\tfill(vl,vl + n, ve[n - 1]);\n\twhile(!topOrder.empty()) {\n\t\tint u = topOrder.top();\n\t\ttopOrder.pop();\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i].v;\n\t\t\tif(vl[v] - G[u][i].w < vl[u]) {\n\t\t\t\t//用u的所有后继结点v的vl值来更新vl[u]\n\t\t\t\tvl[u] = vl[v] - G[u][i].w;\n\t\t\t}\n\t\t}\n\t}\n\t//遍历邻接表的所有边，计算活动的最早开始时间e和最迟开始时间l\n\tfor(int u = 0; u < n; u++) {\n\t\tfor(int i = 0; i < G[u][i].size(); i++) {\n\t\t\tint v = G[u][i].v, w = G[u][i].w;\n\t\t\t//活动的最早开始时间e和最迟开始时间l\n\t\t\tint e = ve[u], l = vl[v] - w;\n\t\t\t//如果e == l，说明活动u->v是关键活动\n\t\t\tif(e == l) {\n\t\t\t\tprintf(\"%d->%d\\n\", u, v); //输出关键活动\n\t\t\t}\n\t\t}\n\t}\n\treturn ve[n - 1]; //返回关键路径长度\n}\n```","tags":["图论"],"categories":["algorithm"]},{"title":"debug","url":"/2019/10/24/warings/","content":"\ndebug 之于 coder\n\n<!-- more -->\n一定一定要会debug！debug！debug！血的教训，从来都不debug的我，上课看老师debuging都不以为意,大佬们给的建议也是左耳进右耳出。花了一下午和一个晚上的时间终于把b站图标给改出来了。以后工作了面对着几千行几万行代码你能一行一行查吗？  \n还有能用框架就用框架！那效率真的不是一般的高！别傻乎乎地一行一行地去敲。\n# 发此博客引以为戒！！！","tags":["警示"],"categories":["techs"]}]