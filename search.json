[{"title":"Be a magical developer","url":"/2019/11/19/ambition/","content":"《一百种自杀方法》最后一页写着活下去。\n<!-- more -->\n\n* [费曼学习法](https://www.choupangxia.com/2019/09/26/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/)  \n* 康奈尔笔记  \n* 计算机组成原理(秃头程序员的进阶感觉可还行)([哈工大](https://www.bilibili.com/video/av15123338))  \n* 数据结构与算法(不C9 无算法 一直都坚信它是程序的灵魂 加油)([北大](https://www.bilibili.com/video/av7134874)+[清华](https://www.bilibili.com/video/av49361421)+算法导论原书第三版)  \n* 操作系统(听说过bug10吧) ([北大](https://www.bilibili.com/video/av6538245))  \n* 计算机网络(学好卖网线)([自顶而下英文原版](./计算机网络原理：自顶向下方法（第6版）.pdf))  \n* 编译原理([哈工大](https://www.bilibili.com/video/av17649289))\n* 嵌入式系统([清华](https://www.bilibili.com/video/av29287517))\n* 信息论与编码（[清华](https://www.bilibili.com/video/av28661250)+[西电](https://www.bilibili.com/video/av26735580)）\n* [机器学习](https://www.bilibili.com/video/av9912938)  \n* 前端  \n* 数据库  \n* 健身  \n* 个人札记  \n    1. 学点经济学\n\t2. 为竞赛而生  \n\t3. 多看英文原版书  \n\t4. 多线程+设计模式  \n\t5. 多看项目源码  \n\t6. 脚踏实地的理想主义者，既要有高远的理想也要有脚踏实地的精神  \n\t7. 他们只是起点比我们高 -- 2018-10-3 打卡南京大学鼓楼校区  \n\t8. 见见有趣的人，读读有趣的书，讲讲有趣的故事。  \n\t9. 有时候我们会觉得自己后知后觉，那是因为学习的太少，了解的太少，很多问题前人已经总结好了现成的方法和方案，我们却不知道，还在自己探索，当然行动缓慢，后知后觉了。只有站在巨人的肩膀上才能看得更远。   \n\t10. 2019-10-26打卡东南大学四牌楼校区图书馆  \n\t11. 备战华北电力大学计算机专硕（[844数据结构](./华北电力大学2020专业课大纲.doc)）  \n\t12. [C语言笔记](https://app.yinxiang.com/shard/s40/nl/24222849/82d590e6-3c3b-4af1-87c2-8964f41501e9/)  \n","tags":["成长"],"categories":["techs"]},{"title":"大学阅读记录","url":"/2019/11/07/book/","content":"读傻了吧你\n<!-- more -->\n\t由于博览群书（名）想不起来全部的书，下面列举了一些个人觉得值得一读的书。\n## 1. 算法类\n![0](./images/QQ20180731-151440@2x.png)\n![1](./images/QQ20180731-190112@2x.png)\n![11](./images/20191107-2373273@2x.png)\n![12](./images/20191107-4662123@2x.png)\n![13](./images/20191107-2633627@2x.png)\n![13](./images/20191107-3522626@2x.png)\n![3](./images/QQ20180731-190810@2x.png)\n## 2. 竞赛类\n![4](./images/QQ20180731-191158@2x.png)\n![5](./images/QQ20180731-192227@2x.png)\n![2](./images/QQ20180731-191409@2x.png)\n## 3. 语言类杂书\n![6](./images/20191107-2342849@2x.png)\n![7](./images/20191107-3648283@2x.png)\n![8](./images/20191107-2433326@2x.png)\n![9](./images/20191107-3281282@2x.png)\n## 4. Python学习\n![10](./images/QQ20180731-210023@2x.png)\n","tags":["阅读"],"categories":["books"]},{"title":"图论算法合集","url":"/2019/11/01/Graph/","content":"\n图论我不会啊~\n\n<!-- more -->\n# 图的遍历\n    * 有两种存储方式：邻接矩阵和邻接表\n    * 在一些顶点数目比较大（一般顶点个数在1000以上）的情况下，使用邻接表而  \n    不是邻接矩阵来存储图。如果是稀疏图，用邻接表，如果是稠密图，用邻接矩阵。\n\n## 深度优先搜索dfs遍历图\n* 按深度优先的方式访问所有未被访问的结点，在结点被访问过后标记为已访问\n```\ndfs(u) {\n  vis[u] = true;\n  for(从u出发到能到达的所有顶点v)\n    if(vis[v] == false)\n      dfs(v);\n}\ndfsTrave(G) {\n  for(G的所有结点u)\n    if(vis[u] == false)\n      dfs(u);\n}\n```\n\n```  \n//邻接矩阵版 DFS\n\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool visited[maxV] = {false};//记录顶点是否被访问过\n\nvoid dfs(int u, int depth) {\n    visited[u] = true;\n    //在这里可以对u进行操作\n    for(int v = 0; v < n; ++v)//遍历u可以到达的顶点\n        if(visited[v] == false && G[u][v] != INF)\n            dfs(v, depth + 1);//访问v 深度+1\n}\n\nvoid travelDFS() {\n    for(int u = 0; u < n; ++u)\n        if(visited[u] == false)\n            dfs(u, 1);\n}```\n```\n//邻接表版 DFS\nvoid dfs(int u, int depth) {\n  vis[u] = true;\n  for(int u = 0; u < arr[u].size(); u++)\n    dfs(v, depth + 1);\n}\n\nvoid dfsTrave() {\n  for(int u = 0; u < n; u++) {\n    if(vis[u] == false)\n      dfs(u, 1);\n  }\n}\n```\n## 广度优先搜索bfs遍历图\n* 建立一个队列，把初始定点加入队列，然后每次都取出队首元素进行访问，并把该定点  \n除法可以到达的未曾加入过队列（而不是未访问）的定点全部加入队列，直到队列为空。\n```\nbfs(u) {\n  queue q;\n  将u入队\n  inq[u] = true;\n  while(q非空) {\n    for(从u出发到可到达的所有顶点v) {\n      if(inq[v] == false)\n        将v入队\n        inq[v] = true;\n    }\n  }\n}\nbfsTrave(G) {\n  for(G的所有顶点u) {\n    if(inq[u] == false)\n      bfs(u);\n  }\n}\n```\n\n```\n//邻接矩阵版 BFS\nint n, G[maxV][maxV];//n顶点数 maxV最大顶点数\nbool inq[maxV] = {false};//记录顶点的是否入队\n\nvoid bfs(int u) {//u顶点编号\n\tqueue<int> q;\n\tq.push(u);//入队\n\tinq[u] = true;//标记u已入队\n\twhile(!q.empty()) {\n\t\tint temp = q.front();//出队\n\t\tq.pop();\n\t\tprintf(\"%d\\n\", temp);//操作\n\t\tfor(int v = 0; v < n; ++v)//遍历u所在连通块（未入队）并入队\n\t\t\tif(inq[v] == false && G[u][v] != INF){\n\t\t\t\tq.push(v);//入队\n\t\t\t\tinq[v] = true;\n\t\t\t}\n\t}\n}//bfs end\n\n/*邻接表：\nfor(int i = 0; i < arr[u].size(); i++) {\n  int v= arr[u][i];\n  if(inq[v] == false) {\n    q.push(v);\n    inq[v] = true;\n  }\n}\n*/\n\nvoid travelBFS() {\n\tfor(int v; v < n; ++v)\n\t\tif (inq[v] == false)\n\t\t\tbfs(v);//遍历v所在连通块\n}```\n\n```\n//带层数的 邻接表\nstruct node {\n  int v;//顶点编号\n  int layer;//顶点层号\n};\nnext.layer = top.layer + 1;\n//邻接表中的类型是node，而不是int\nvector<node> Adj[N]\n```\n<!--# 最短路径\n\t单源最短路径：计算源点到其他各顶点的最短路径的长度\n\t全局最短路径：图中任意两点的最短路径\n\tDijkstra、Bellman-Ford、SPFA求单源最短路径\n\tFloyed可以求全局最短路径，但是效率比较低\n\tSPFA算法是Bellman-Ford算法的队列优化\n\tDijkstra算法不能求带负权边的最短路径，而SPFA算法、Bellman-Ford算法、Floyd-Warshall可以求带负权边的最短路径。\n\tBellman-Ford算法的核心代码只有4行，Floyd-Warshall算法的核心代码只有5行。\n\t深度优先遍历可以求一个点到另一个点的最短路径的长度\n## 单源最短路径\n思想来源：图的广度优先遍历bfs\n![1](./images/latestPath.png)-->","tags":["图论"],"categories":["algorithm"]},{"title":"debug","url":"/2019/10/24/warings/","content":"\ndebug 之于 coder\n\n<!-- more -->\n一定一定要会debug！debug！debug！血的教训，从来都不debug的我，上课看老师debuging都不以为意,大佬们给的建议也是左耳进右耳出。花了一下午和一个晚上的时间终于把b站图标给改出来了。以后工作了面对着几千行几万行代码你能一行一行查吗？  \n还有能用框架就用框架！那效率真的不是一般的高！别傻乎乎地一行一行地去敲。\n# 发此博客引以为戒！！！","tags":["警示"],"categories":["techs"]}]